<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Michel Billaud (michel.billaud@laposte.net)" />
  <title>Une Conjecture sur les Mots</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <style type="text/css">a.sourceLine {
display: inline-block;
line-height: 1.25;
}
a.sourceLine {
pointer-events: none;
color: inherit;
text-decoration: inherit;
}
a.sourceLine:empty {
height: 1.2em;
}
.sourceCode {
overflow: visible;
}
code.sourceCode {
white-space: pre;
position: relative;
}
div.sourceCode {
margin: 1em 0;
}
pre.sourceCode {
margin: 0;
}
@media screen {
div.sourceCode {
overflow: auto;
}
}
@media print {
code.sourceCode {
white-space: pre-wrap;
}
a.sourceLine {
text-indent: -1em;
padding-left: 1em;
}
}
pre.numberSource a.sourceLine {
position: relative;
left: -4em;
}
pre.numberSource a.sourceLine::before {
content: attr(title);
position: relative;
left: -1em;
text-align: right;
vertical-align: baseline;
border: none;
pointer-events: all;
display: inline-block;
-webkit-touch-callout: none;
-webkit-user-select: none;
-khtml-user-select: none;
-moz-user-select: none;
-ms-user-select: none;
user-select: none;
padding: 0 4px;
width: 4em;
color: #aaaaaa;
}
pre.numberSource {
margin-left: 3em;
border-left: 1px solid #aaaaaa;
padding-left: 4px;
}
div.sourceCode {}
@media screen {
a.sourceLine::before {
text-decoration: underline;
}
}
code span.al {
color: #ff0000;
font-weight: bold;
}

code span.an {
color: #60a0b0;
font-weight: bold;
font-style: italic;
}

code span.at {
color: #7d9029;
}

code span.bn {
color: #40a070;
}

code span.bu {}

code span.cf {
color: #007020;
font-weight: bold;
}

code span.ch {
color: #4070a0;
}

code span.cn {
color: #880000;
}

code span.co {
color: #60a0b0;
font-style: italic;
}

code span.cv {
color: #60a0b0;
font-weight: bold;
font-style: italic;
}

code span.do {
color: #ba2121;
font-style: italic;
}

code span.dt {
color: #902000;
}

code span.dv {
color: #40a070;
}

code span.er {
color: #ff0000;
font-weight: bold;
}

code span.ex {}

code span.fl {
color: #40a070;
}

code span.fu {
color: #06287e;
}

code span.im {}

code span.in {
color: #60a0b0;
font-weight: bold;
font-style: italic;
}

code span.kw {
color: #007020;
font-weight: bold;
}

code span.op {
color: #666666;
}

code span.ot {
color: #007020;
}

code span.pp {
color: #bc7a00;
}

code span.sc {
color: #4070a0;
}

code span.ss {
color: #bb6688;
}

code span.st {
color: #4070a0;
}

code span.va {
color: #19177c;
}

code span.vs {
color: #4070a0;
}

code span.wa {
color: #60a0b0;
font-weight: bold;
font-style: italic;
}


:root {
--title-color: #202080;
--source-bg-color: rgb(240, 240, 255);
}
h1, h2, h3, h4, h5, h6 {
border-bottom: solid 1px silver;
color: var(--title-color);
}
body {
font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
}
div.sourceCode {
background-color: var(--source-bg-color);
padding: 1em;
}
#TOC {
padding: 0.5em;
border: solid 1px silver;
}
#TOC ul {
list-style-type: none;
padding-left: 1em;
}
nav:before {
text-indent: 2em;
content: "Sommaire";
color: var(--title-color);
font-weight: bold;
font-size: large;
}
#TOC a {
text-decoration: none;
}
header {
text-align: center;
}
.title {
}
.author, .date {
font-style: italic;
}
table, th, td {
border-collapse: collapse;
border: solid black 1px;
padding: 0.5em;
}
</style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Une Conjecture sur les Mots</h1>
<p class="author">Michel Billaud (michel.billaud@laposte.net)</p>
<p class="date">21 juillet 2022</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#quelques-définitions"><span class="toc-section-number">1</span> Quelques définitions</a>
<ul>
<li><a href="#mots"><span class="toc-section-number">1.1</span> Mots</a></li>
<li><a href="#morphisme"><span class="toc-section-number">1.2</span> Morphisme</a></li>
<li><a href="#points-fixes-dun-morphisme"><span class="toc-section-number">1.3</span> Points-fixes d’un morphisme</a></li>
</ul></li>
<li><a href="#morphismes-qui-ont-un-mot-comme-point-fixe"><span class="toc-section-number">2</span> Morphismes qui ont un mot comme point-fixe</a>
<ul>
<li><a href="#mots-primitifs-qui-ne-sont-points-fixes-que-par-lidentité"><span class="toc-section-number">2.1</span> Mots primitifs : qui ne sont points fixes que par l’identité</a></li>
<li><a href="#la-conjecture"><span class="toc-section-number">2.2</span> La conjecture</a></li>
</ul></li>
<li><a href="#bibliographie"><span class="toc-section-number">3</span> Bibliographie</a>
<ul>
<li><a href="#richomme-g-levé-f-2005"><span class="toc-section-number">3.1</span> Richomme G, Levé F (2005)</a></li>
<li><a href="#łopaciuk-s.-reidenbach-d.-2022."><span class="toc-section-number">3.2</span> Łopaciuk, S., Reidenbach, D. (2022).</a></li>
<li><a href="#łopaciuk-s.-reidenbach-d.-2021."><span class="toc-section-number">3.3</span> Łopaciuk, S., Reidenbach, D. (2021).</a></li>
<li><a href="#reidenbach-d.-schneider-j.c.-2009"><span class="toc-section-number">3.4</span> Reidenbach D., Schneider J.C. (2009)</a></li>
<li><a href="#holub-š.-2009"><span class="toc-section-number">3.5</span> Holub, Š. (2009)</a></li>
<li><a href="#t.-kociumaka-j.-radoszewski-w.-rytter-t.-waleń-2015"><span class="toc-section-number">3.6</span> T. Kociumaka, J. Radoszewski, W. Rytter, T. Waleń, (2015)</a></li>
<li><a href="#filè-g.-1989"><span class="toc-section-number">3.7</span> Filè, G. (1989)</a></li>
</ul></li>
</ul>
</nav>
<p><img src="data:image/png;base64,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" /></p>
<p>Ce texte fait partie d’une petite <a href="index.html">collection de notes</a> mise à disposition selon les termes de la <a href="http://creativecommons.org/licenses/by-nc-sa/2.0/fr/">Licence Creative Commons Attribution - Pas d’Utilisation Commerciale - Partage dans les Mêmes Conditions 2.0 France</a>.</p>
<ul>
<li>Les notes sont publiées dans <a href="https://www.mbillaud.fr/notes/" class="uri">https://www.mbillaud.fr/notes/</a></li>
<li>Sources dans <a href="https://github.com/MichelBillaud/notes-diverses" class="uri">https://github.com/MichelBillaud/notes-diverses</a></li>
</ul>
<p>Il y a très longtemps (vers 1988), je m’étais posé un petit problème, que je n’ai pas réussi à résoudre. Rien d’étonnant, c’était pas dans mon domaine, et je n’y ai travaillé que mollement. Donc j’ai laissé tomber rapidement, mais après avoir appelé à l’aide sur Usenet, qui ne manque pas de gens plus compétents.</p>
<p>On en retrouve des traces dans le newsgroup <code>comp.theory</code> en 1993, mais j’avais dû déjà poser la question en 1988, puisque je me rappelle très bien (pour une fois) en avoir discuté avec Gilberto Filè dont je partageais le bureau, avant le STACS 1988 (j’ai une copie de son manuscript, écrite à la main, quelque part !).</p>
<blockquote>
<p>Given a word <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math>, if for each letter <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> occurring in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math>, there exists non-trivial morphism <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mi>x</mi></msub><annotation encoding="application/x-tex">f_x</annotation></semantics></math> such that the word obtained by erasing all the occurrences of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is a fixed point of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mi>x</mi></msub><annotation encoding="application/x-tex">f_x</annotation></semantics></math>, then there exists a non-trivial morphism <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> such that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math> is a fixed point of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>.</p>
</blockquote>
<p>Et bon, surprise, on est en 2022, mais apparemment c’est toujours pas résolu.</p>
<p>Bon, peut-être que c’est pas très clair, alors j’explique :</p>
<h1 data-number="1" id="quelques-définitions"><span class="header-section-number">1</span> Quelques définitions</h1>
<p>Je suppose que vous avez quand même entendu parler de mots construits sur un alphabet. Sinon, c’est pas compliqué</p>
<h2 data-number="1.1" id="mots"><span class="header-section-number">1.1</span> Mots</h2>
<ul>
<li>un <strong>alphabet</strong> c’est un ensemble, donc les éléments sont appelés <strong>lettres</strong>. Exemple <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo>,</mo><mi>d</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">A = \{a, b, c, d\}</annotation></semantics></math>.</li>
<li>un <strong>mot</strong>, c’est une séquence de lettres, exemple <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi><mi>b</mi><mi>a</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">abcbad</annotation></semantics></math>.</li>
<li>on appelle traditionnellement <strong>langage</strong> un ensemble de mots (sans restriction particulière).</li>
<li>le mot vide, c’est la séquence vide, qu’on note souvent <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ϵ</mi><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></li>
<li>la <strong>concaténation</strong> de deux mots, c’est quand on les met bout à bout. On la note souvent par un point. Par exemple, $ab . cbad = abcbad&quot;.</li>
<li>par commodité, on confond la notation d’une lettre avec le mot qui ne contient que cette lettre.</li>
</ul>
<h2 data-number="1.2" id="morphisme"><span class="header-section-number">1.2</span> Morphisme</h2>
<p>En général, un <strong>morphisme</strong> est une application d’un ensemble vers un autre qui préserve une opération.</p>
<p>Ici on considére les morphismes entre deux ensembles de mots (construits sur des alphabets différents ou pas) qui préservent la concaténation.</p>
<p>C’est-à-dire que si <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> est un morphisme, pour tous mots <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>,</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u, v</annotation></semantics></math> on a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>u</mi><mi>.</mi><mi>v</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>u</mi><mo stretchy="false" form="postfix">)</mo><mi>.</mi><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f(u.v) = f(u).f(v)</annotation></semantics></math>.</p>
<p>Une conséquence est qu’un morphisme est déterminé par la connaissance des images des lettres de l’alphabet. C’est évident : si on connait <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f(a)</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f(b)</annotation></semantics></math> etc. alors on peut calculer l’image des mots formés à partir des lettres <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">a, b,...</annotation></semantics></math> etc.</p>
<p>La notion s’étend à des langages (ensembles de mots) : l’image d’un ensemble de mots par un morphisme, c’est l’ensemble des images par le morphisme.</p>
<h2 data-number="1.3" id="points-fixes-dun-morphisme"><span class="header-section-number">1.3</span> Points-fixes d’un morphisme</h2>
<p>On regarde maintenant les morphismes dans le cas où les ensembles de départ et d’arrivée sont les mêmes. Automorphismes ?</p>
<p>Un <strong>point fixe du morphisme</strong> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>, c’est un mot <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math> qui est sa propre image par <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> (c-a-d <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>w</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">f(w) = w</annotation></semantics></math>).</p>
<p>Exemple <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">ab</annotation></semantics></math> est un point fixe pour <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>a</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">f(a) = ab</annotation></semantics></math> et <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">f(b) = \epsilon</annotation></semantics></math>.</p>
<p>Un morphisme n’admet pas forcément de point fixe, exemple évident : le morphisme qui double chaque lettre : <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>a</mi><mi>a</mi><mo>,</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>b</mi><mi>b</mi><mo>,</mo><mo>;</mo><mi>.</mi><mi>.</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">f(a) = aa, f(b) = bb, ;...</annotation></semantics></math>.</p>
<p>Mais quand il en admet un, il en admet une infinité : si <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>w</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">f(w) = w</annotation></semantics></math>, alors <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>w</mi><mi>n</mi></msup><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msup><mi>w</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">f(w^n) = w^n</annotation></semantics></math>.</p>
<h1 data-number="2" id="morphismes-qui-ont-un-mot-comme-point-fixe"><span class="header-section-number">2</span> Morphismes qui ont un mot comme point-fixe</h1>
<p>On aurait pu s’amuser avec les propriétés de l’ensemble des points fixes d’un morphisme, mais on part dans la direction inverse :</p>
<ul>
<li>on prend un mot <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math> au départ</li>
<li>quels morphismes l’admettent comme point fixe ?</li>
</ul>
<p>Ce qui amène quelques observations :</p>
<ul>
<li>il y en a toujours au moins un : le morphisme identité.</li>
<li>si on en a un, tous les morphismes obtenus en faisant varier les images des lettres qui n’apparaissent pas dans le mot font aussi l’affaire.</li>
</ul>
<p>Exemple : si on part du mot <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>=</mo><mi>a</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">w = aa</annotation></semantics></math>, on a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>w</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">f(w)=w</annotation></semantics></math> si et seulement si <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">f(a) = a</annotation></semantics></math>. Les valeurs de <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f(b)</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f(c)</annotation></semantics></math> etc. sont indifférentes.</p>
<p>On va donc se concentrer sur les morphismes restreints aux lettres qui apparaissent dans le mot.</p>
<h2 data-number="2.1" id="mots-primitifs-qui-ne-sont-points-fixes-que-par-lidentité"><span class="header-section-number">2.1</span> Mots primitifs : qui ne sont points fixes que par l’identité</h2>
<p>Ce qui nous intéresse, c’est les mots qui ne sont leur propre image <strong>que d’une seule et unique façon</strong> : par l’identité.</p>
<p>Exemples : <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">aa</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>a</mi><mi>n</mi></msup><annotation encoding="application/x-tex">a^n</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>b</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">abba</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>a</mi><mi>b</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">ababa</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mi>b</mi><msup><mo stretchy="false" form="postfix">)</mo><mi>n</mi></msup><mi>a</mi></mrow><annotation encoding="application/x-tex">(ab)^na</annotation></semantics></math>, etc.</p>
<p>Contre-exemple : <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>a</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">abab</annotation></semantics></math>, en prenant <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>a</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">f(a)=ab</annotation></semantics></math> et <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">f(b)=\epsilon</annotation></semantics></math>.</p>
<p>Il est bien évident qu’il y en a une infinité (cf. les exemples <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>a</mi><mi>n</mi></msup><annotation encoding="application/x-tex">a^n</annotation></semantics></math>).</p>
<p>On va les appeler “mots primitifs”.</p>
<h2 data-number="2.2" id="la-conjecture"><span class="header-section-number">2.2</span> La conjecture</h2>
<p>Informellement, la question c’est</p>
<blockquote>
<p>tout mot primitif sur un alphabet à <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> lettres peut-il être obtenu à partir d’un mot primitif sur un alphabet à <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math> lettres, en y insérant judicieusement des occurrences de la lettre supplémentaire ?</p>
</blockquote>
<p>Exemple</p>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>b</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">abba</annotation></semantics></math> : à partir de <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">aa</annotation></semantics></math> ou <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">bb</annotation></semantics></math>,</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi><mi>a</mi><mi>c</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">abcacb</annotation></semantics></math> : à partir de <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>c</mi><mi>c</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">bccb</annotation></semantics></math>, mais pas de <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>a</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">abab</annotation></semantics></math> ou <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>c</mi><mi>a</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">acac</annotation></semantics></math> qui ne sont pas primitifs.</li>
</ul>
<p>Bref, posé dans l’autre sens :</p>
<blockquote>
<p>pour tout mot primitif <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math>, existe-t-il au moins une lettre <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> dans <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math> qu’on pourrait effacer pour retomber sur un mot primitif ?</p>
</blockquote>
<p>Les énumérations par programme n’ont jusqu’ici pas trouvé de contre-exemple, et on conjecture que oui.</p>
<p>Mais la preuve reste à faire.</p>
<h1 data-number="3" id="bibliographie"><span class="header-section-number">3</span> Bibliographie</h1>
<p>Dans un ordre aléatoire, en cours de construction.</p>
<p>Disclaimer : je ne les ai pas tous lus, il en manque, et ils n’ont pas forcément tous un rapport direct. Mais c’est intéressant de voir pourquoi l’existence d’un morphisme entre deux mots est un problème NP-complet, ou d’apprendre qu’il existe un algo linéaire pour vois si un mot est “primitif” ou pas.</p>
<h2 data-number="3.1" id="richomme-g-levé-f-2005"><span class="header-section-number">3.1</span> Richomme G, Levé F (2005)</h2>
<p>Gwenaël Richomme, Florence Levé. On a conjecture about finite fixed points of morphisms. Theoretical Computer Science, Elsevier, 2005, 339, pp.103-128. (hal-00599741)</p>
<ul>
<li>Hal <a href="https://hal.archives-ouvertes.fr/hal-00599741" class="uri">https://hal.archives-ouvertes.fr/hal-00599741</a></li>
<li><a href="https://www.sciencedirect.com/science/article/pii/S0304397505000277" class="uri">https://www.sciencedirect.com/science/article/pii/S0304397505000277</a></li>
</ul>
<p>Abstract : A conjecture of M. Billaud is: Given a word <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math>, if, for each letter <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> occurring in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math>, the word obtained by erasing all the occurrences of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math> is a fixed point of a nontrivial morphism <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mi>x</mi></msub><annotation encoding="application/x-tex">f_x</annotation></semantics></math>, then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math> is also a fixed point of a nontrivial morphism. We prove that this conjecture is equivalent to a similar one on sets of words. Using this equivalence, we solve these conjectures in the particular case where each morphism <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mi>x</mi></msub><annotation encoding="application/x-tex">f_x</annotation></semantics></math> has only one expansive letter.</p>
<h2 data-number="3.2" id="łopaciuk-s.-reidenbach-d.-2022."><span class="header-section-number">3.2</span> Łopaciuk, S., Reidenbach, D. (2022).</h2>
<p>Łopaciuk, S., Reidenbach, D. (2022). The Billaud Conjecture for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">|</mo><mi>Σ</mi><mo stretchy="false" form="prefix">|</mo><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">| \Sigma | = 4</annotation></semantics></math>, and Beyond. In: Diekert, V., Volkov, M. (eds) Developments in Language Theory. DLT 2022. Lecture Notes in Computer Science, vol 13257. Springer, Cham. <a href="https://doi.org/10.1007/978-3-031-05578-2_17" class="uri">https://doi.org/10.1007/978-3-031-05578-2_17</a></p>
<p>Abstract. The Billaud Conjecture, first stated in 1993, is a fundamental problem on finite words and their heirs, i.e., the words obtained by a projection deleting a single letter. The conjecture states that every morphically primitive word, i.e., a word which is not a fixed point of any non-identity morphism, has at least one morphically primitive heir. In this paper we give the proof of the Conjecture for alphabet size 4, and discuss the potential for generalising our reasoning to larger alphabets. We briefly discuss how other language-theoretic tools relate to the Conjecture, and their suitability for potential generalisations.</p>
<h2 data-number="3.3" id="łopaciuk-s.-reidenbach-d.-2021."><span class="header-section-number">3.3</span> Łopaciuk, S., Reidenbach, D. (2021).</h2>
<p>Łopaciuk, S., Reidenbach, D. (2021). On Billaud Words and Their Companions. In: Lecroq, T.,&lt; Puzynina, S. (eds) Combinatorics on Words. WORDS 2021. Lecture Notes in Computer Science(), vol 12847. Springer, Cham. <a href="https://doi.org/10.1007/978-3-030-85088-3_11" class="uri">https://doi.org/10.1007/978-3-030-85088-3_11</a></p>
<p>The Billaud Conjecture, which has been open since 1993, is a fundamental problem on finite words <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math> and their heirs, i.e., the words obtained by deleting every occurrence of a given letter from <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math>. It posits that every morphically primitive word, i.e. a word which is a fixed point of the identity morphism only, has at least one morphically primitive heir. In this paper, we introduce and investigate the related class of so-called Billaud words, i.e. words whose all heirs are morphically imprimitive. We provide a characterisation of morphically imprimitive Billaud words, using a new concept. We show that there are two phenomena through which words can have morphically imprimitive heirs, and we highlight that only one of those occurs in morphically primitive words. Finally, we examine our concept further, use it to rephrase the Billaud Conjecture and study its difficulty.</p>
<ul>
<li><a href="https://repository.lboro.ac.uk/articles/conference_contribution/On_Billaud_words_and_their_companions/14872188" class="uri">https://repository.lboro.ac.uk/articles/conference_contribution/On_Billaud_words_and_their_companions/14872188</a></li>
</ul>
<h2 data-number="3.4" id="reidenbach-d.-schneider-j.c.-2009"><span class="header-section-number">3.4</span> Reidenbach D., Schneider J.C. (2009)</h2>
<p>Daniel Reidenbach and Johannes C. Schneider. Morphically primitive words, Theor. Comp. Sci. 410 (2009) 2148-2161</p>
<p>Abstract. In the present paper, we introduce an alternative notion of the primitivity of words, that -unlike the standard understanding of this term -is not based on the power (and, hence, the concatenation) of words, but on morphisms. For any alphabet <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>, we call a word <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>∈</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">w \in \Sigma^*</annotation></semantics></math> <em>morphically imprimitive</em> provided that there are a shorter word <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>v</mi><annotation encoding="application/x-tex">v</annotation></semantics></math> and morphisms <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>,</mo><mi>h</mi><mi>′</mi><mo>:</mo><msup><mi>Σ</mi><mo>*</mo></msup><mo>→</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">h, h&#39; : \Sigma^* \rightarrow \Sigma^*</annotation></semantics></math> satisfying <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false" form="prefix">(</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">h(v) = w</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>′</mi><mo stretchy="false" form="prefix">(</mo><mi>w</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">h&#39;(w) = v</annotation></semantics></math>, and we say that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math> is <em>morphically primitive</em> otherwise. We explain why this is a well-chosen terminology, we demonstrate that morphic (im-) primitivity of words is a vital attribute in many combinatorial domains based on finite words and morphisms, and we study a number of fundamental properties of the concepts under consideration.</p>
<ul>
<li><a href="https://www.sciencedirect.com/science/article/pii/S030439750900084X?via%3Dihub" class="uri">https://www.sciencedirect.com/science/article/pii/S030439750900084X?via%3Dihub</a></li>
</ul>
<h2 data-number="3.5" id="holub-š.-2009"><span class="header-section-number">3.5</span> Holub, Š. (2009)</h2>
<p>Štěpán Holub, Polynomial algorithm for fixed points of nontrivial morphisms, Discrete Mathematics 309 (2009), 5069-5076</p>
<p>Abstract. A word <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math> is a fixed point of a nontrivial morphism <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math> if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>=</mo><mi>h</mi><mo stretchy="false" form="prefix">(</mo><mi>w</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">w = h(w)</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math> is not the identity on the alphabet of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math>. The paper presents the first polynomial algorithm deciding whether a given finite word is such a fixed point. The algorithm also constructs the corresponding morphism, which has the smallest possible number of non-erased letters.</p>
<ul>
<li><a href="https://www.sciencedirect.com/science/article/pii/S0012365X09001484?via%3Dihub" class="uri">https://www.sciencedirect.com/science/article/pii/S0012365X09001484?via%3Dihub</a></li>
</ul>
<h2 data-number="3.6" id="t.-kociumaka-j.-radoszewski-w.-rytter-t.-waleń-2015"><span class="header-section-number">3.6</span> T. Kociumaka, J. Radoszewski, W. Rytter, T. Waleń, (2015)</h2>
<p>T. Kociumaka, J. Radoszewski, W. Rytter, T. Waleń, Linear-time version of Holub’s algorithm for morphic imprimitivity testing, Theoretical Computer Science, Volume 602, 2015, Pages 7-21, ISSN 0304-3975, <a href="https://doi.org/10.1016/j.tcs.2015.07.055" class="uri">https://doi.org/10.1016/j.tcs.2015.07.055</a></p>
<p>&lt;- https://www.sciencedirect.com/science/article/pii/S0304397515007112&gt;</p>
<p>Abstract: Stepan Holub (Discr. Math., 2009) gave the first polynomial-time algorithm deciding whether a given word is a nontrivial fixed point of a morphism. His algorithm works in quadratic time for large alphabets. We improve the algorithm to work in linear time. Our improvement starts with a careful choice of a subset of rules used in Holub’s algorithm that is necessary to grant correctness of the algorithm. Afterwards we show how to choose the order of applying the rules that allows to avoid unnecessary operations on sets. We obtain linear time using efficient data structures for implementation of the rules. Holub’s algorithm maintains connected components of a graph corresponding to specially marked positions in a word. This graph is of quadratic size for large alphabet. In our algorithm only a linear number of edges of this conceptual graph is processed. A preliminary version of this paper appeared at LATA 2013 conference.</p>
<h2 data-number="3.7" id="filè-g.-1989"><span class="header-section-number">3.7</span> Filè, G. (1989)</h2>
<p>Filè, G.: The relation of two patterns with comparable languages patterns. RAIRO - Theoretical Informatics and Applications - Informatique Théorique et Applications 23(1), 45–57 (1989)</p>
<p>Gilberto Filé: The Relation of Two Patterns with Comparable Languages. STACS 1988: 184-192</p>
</body>
</html>
