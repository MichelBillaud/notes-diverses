<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Michel Billaud (michel.billaud@laposte.net)" />
  <title>Réalisation d’un shell en C</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style type="text/css">a.sourceLine {
display: inline-block;
line-height: 1.25;
}
a.sourceLine {
pointer-events: none;
color: inherit;
text-decoration: inherit;
}
a.sourceLine:empty {
height: 1.2em;
}
.sourceCode {
overflow: visible;
}
code.sourceCode {
white-space: pre;
position: relative;
}
div.sourceCode {
margin: 1em 0;
}
pre.sourceCode {
margin: 0;
}
@media screen {
div.sourceCode {
overflow: auto;
}
}
@media print {
code.sourceCode {
white-space: pre-wrap;
}
a.sourceLine {
text-indent: -1em;
padding-left: 1em;
}
}
pre.numberSource a.sourceLine {
position: relative;
left: -4em;
}
pre.numberSource a.sourceLine::before {
content: attr(title);
position: relative;
left: -1em;
text-align: right;
vertical-align: baseline;
border: none;
pointer-events: all;
display: inline-block;
-webkit-touch-callout: none;
-webkit-user-select: none;
-khtml-user-select: none;
-moz-user-select: none;
-ms-user-select: none;
user-select: none;
padding: 0 4px;
width: 4em;
color: #aaaaaa;
}
pre.numberSource {
margin-left: 3em;
border-left: 1px solid #aaaaaa;
padding-left: 4px;
}
div.sourceCode {}
@media screen {
a.sourceLine::before {
text-decoration: underline;
}
}
code span.al {
color: #ff0000;
font-weight: bold;
}

code span.an {
color: #60a0b0;
font-weight: bold;
font-style: italic;
}

code span.at {
color: #7d9029;
}

code span.bn {
color: #40a070;
}

code span.bu {}

code span.cf {
color: #007020;
font-weight: bold;
}

code span.ch {
color: #4070a0;
}

code span.cn {
color: #880000;
}

code span.co {
color: #60a0b0;
font-style: italic;
}

code span.cv {
color: #60a0b0;
font-weight: bold;
font-style: italic;
}

code span.do {
color: #ba2121;
font-style: italic;
}

code span.dt {
color: #902000;
}

code span.dv {
color: #40a070;
}

code span.er {
color: #ff0000;
font-weight: bold;
}

code span.ex {}

code span.fl {
color: #40a070;
}

code span.fu {
color: #06287e;
}

code span.im {}

code span.in {
color: #60a0b0;
font-weight: bold;
font-style: italic;
}

code span.kw {
color: #007020;
font-weight: bold;
}

code span.op {
color: #666666;
}

code span.ot {
color: #007020;
}

code span.pp {
color: #bc7a00;
}

code span.sc {
color: #4070a0;
}

code span.ss {
color: #bb6688;
}

code span.st {
color: #4070a0;
}

code span.va {
color: #19177c;
}

code span.vs {
color: #4070a0;
}

code span.wa {
color: #60a0b0;
font-weight: bold;
font-style: italic;
}


:root {
--title-color: #202080;
--source-bg-color: rgb(240, 240, 255);
}
h1, h2, h3, h4, h5, h6 {
border-bottom: solid 1px silver;
color: var(--title-color);
}
body {
font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
}
div.sourceCode {
background-color: var(--source-bg-color);
padding: 1em;
}
#TOC {
padding: 0.5em;
border: solid 1px silver;
}
#TOC ul {
list-style-type: none;
padding-left: 1em;
}
nav:before {
text-indent: 2em;
content: "Sommaire";
color: var(--title-color);
font-weight: bold;
font-size: large;
}
#TOC a {
text-decoration: none;
}
header {
text-align: center;
}
.title {
}
.author, .date {
font-style: italic;
}
table, th, td {
border-collapse: collapse;
border: solid black 1px;
padding: 0.5em;
}
</style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Réalisation d’un shell en C</h1>
<p class="author">Michel Billaud (michel.billaud@laposte.net)</p>
<p class="date">3 février 2023</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#objectif"><span class="toc-section-number">1</span> Objectif</a></li>
<li><a href="#première-étape-faire-une-boucle-de-dialogue"><span class="toc-section-number">2</span> Première étape : faire une boucle de dialogue</a>
<ul>
<li><a href="#utilisation-de-getline"><span class="toc-section-number">2.1</span> Utilisation de <code>getline()</code></a></li>
<li><a href="#code-de-démonstration"><span class="toc-section-number">2.2</span> Code de démonstration</a></li>
<li><a href="#exemple-dexécution"><span class="toc-section-number">2.3</span> Exemple d’exécution</a></li>
<li><a href="#compilation-et-exécution"><span class="toc-section-number">2.4</span> Compilation et exécution</a></li>
<li><a href="#vérification-des-fuites-mémoires"><span class="toc-section-number">2.5</span> Vérification des fuites mémoires</a></li>
</ul></li>
<li><a href="#seconde-étape-représenter-un-tableau-de-chaînes"><span class="toc-section-number">3</span> Seconde étape : représenter un tableau de chaînes</a>
<ul>
<li><a href="#code-des-tests-fonctionnalités-tests-ptr-array.c"><span class="toc-section-number">3.1</span> Code des tests, fonctionnalités (<code>tests-ptr-array.c</code>)</a></li>
<li><a href="#fichier-den-tête-ptr-array.h"><span class="toc-section-number">3.2</span> Fichier d’en-tête <code>ptr-array.h</code></a></li>
<li><a href="#implémentation-des-fonctions-ptr-array.c"><span class="toc-section-number">3.3</span> Implémentation des fonctions <code>ptr-array.c</code></a></li>
<li><a href="#compilation-et-exécution-des-tests"><span class="toc-section-number">3.4</span> Compilation et exécution des tests</a></li>
</ul></li>
<li><a href="#troisième-étape-découpage-de-la-ligne"><span class="toc-section-number">4</span> Troisième étape : découpage de la ligne</a>
<ul>
<li><a href="#tests-du-découpage-test-split-line.c"><span class="toc-section-number">4.1</span> Tests du découpage (<code>test-split-line.c</code>)</a></li>
<li><a href="#le-fichier-dentête-split-line.h"><span class="toc-section-number">4.2</span> Le fichier d’entête (<code>split-line.h</code>)</a></li>
<li><a href="#le-code-du-découpage-split-line.c"><span class="toc-section-number">4.3</span> Le code du découpage (<code>split-line.c</code>)</a></li>
</ul></li>
<li><a href="#lexécution-des-commandes"><span class="toc-section-number">5</span> L’exécution des commandes</a>
<ul>
<li><a href="#la-structure-command_result"><span class="toc-section-number">5.1</span> La structure <code>command_result</code></a></li>
<li><a href="#la-fonction-main"><span class="toc-section-number">5.2</span> La fonction <code>main()</code></a></li>
<li><a href="#les-commandes-internes"><span class="toc-section-number">5.3</span> Les commandes internes</a></li>
<li><a href="#la-fonction-execute_command"><span class="toc-section-number">5.4</span> La fonction <code>execute_command()</code></a></li>
<li><a href="#lancement-dun-programme-par-execute_external_command"><span class="toc-section-number">5.5</span> Lancement d’un programme par <code>execute_external_command()</code></a></li>
</ul></li>
<li><a href="#exemple-dexécution-1"><span class="toc-section-number">6</span> Exemple d’exécution</a></li>
<li><a href="#conclusion"><span class="toc-section-number">7</span> Conclusion</a></li>
<li><a href="#annexes"><span class="toc-section-number">8</span> Annexes</a>
<ul>
<li><a href="#code-entier-mini-shell.c"><span class="toc-section-number">8.1</span> Code entier <code>mini-shell.c</code></a></li>
<li><a href="#makefile-utilisé"><span class="toc-section-number">8.2</span> <code>Makefile</code> utilisé</a></li>
<li><a href="#exemple-de-recompilation-complète"><span class="toc-section-number">8.3</span> Exemple de recompilation complète</a></li>
</ul></li>
</ul>
</nav>
<h1 data-number="1" id="objectif"><span class="header-section-number">1</span> Objectif</h1>
<p>La réalisation d’un mini-<em>shell</em> (interprète de commandes) est un projet classique de programmation système en C.</p>
<p>Dans sa version la plus simpliste, un shell est une boucle qui</p>
<ul>
<li>affiche une chaîne d’invite (<em>prompt</em>),</li>
<li>lit une commande,</li>
<li>lance son exécution,</li>
<li>et recommence.</li>
</ul>
<p>Les commandes sont des suites de mots : en général le chemin d’accès d’un programme (exécutable), suivi par des options, des arguments…</p>
<p>Il y a aussi des commandes dites <em>internes</em>, par exemple <code>exit</code>, qui fait arrêter la boucle du shell. Un autre exemple est la commande <code>cd</code> qui change le répertoire courant.</p>
<p>Ce document montre un point de départ pour la réalisation d’un tel shell, avec une version qui exécute des commandes simples.</p>
<h1 data-number="2" id="première-étape-faire-une-boucle-de-dialogue"><span class="header-section-number">2</span> Première étape : faire une boucle de dialogue</h1>
<p>Le dialogue se fait sur la base d’une boucle qui</p>
<ul>
<li>demande à l’utilisateur de taper quelque chose,</li>
<li>lit la ligne qui a été tapée,</li>
<li>fait quelque chose avec,</li>
<li>et recommence ;</li>
</ul>
<p>et ceci, tant qu’on n’a pas tapé quelque chose de particulier qui dit d’arrêter.</p>
<h2 data-number="2.1" id="utilisation-de-getline"><span class="header-section-number">2.1</span> Utilisation de <code>getline()</code></h2>
<p>Pour lire une ligne utilisateur, on peut recommander d’utiliser la fonction <code>getline</code>, qui lit une ligne complète sans limitation de taille. C’est une fonction standard POSIX.</p>
<p>Elle travaille avec un tampon, tableau de caractères qui est alloué et rallongé automatiquement au besoin. Ce tampon est décrit par deux variables</p>
<ul>
<li>un pointeur qui indique son début (initialement on y met <code>NULL</code>),</li>
<li>sa taille dans un entier (initialement 0),</li>
</ul>
<p>dont on passe l’adresse à la fonction <code>getline()</code>.</p>
<p>La fonction <code>getline()</code> repose sur la gestion du tampon par <code>alloc()</code> et <code>realloc</code>().</p>
<h2 data-number="2.2" id="code-de-démonstration"><span class="header-section-number">2.2</span> Code de démonstration</h2>
<p>Le code ci-dessous montre la réalisation d’une boucle avec lecture par <code>getline()</code></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">// demo-boucle.c</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>{</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>    <span class="dt">char</span> *line = NULL;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>    <span class="dt">size_t</span> line_size = <span class="dv">0</span>;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>    printf(<span class="st">&quot;--- Démo Boucle</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a>    printf(<span class="st">&quot;tapez exit pour arrêter</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a>    <span class="dt">int</span> numero = <span class="dv">1</span>;</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">bool</span> run_loop = true; run_loop; ) {</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a>        printf(<span class="st">&quot;%d&gt; &quot;</span>, numero);</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a>        <span class="dt">int</span> length = getline(&amp; line, &amp;line_size, stdin);</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a>        <span class="cf">if</span> (length &lt; <span class="dv">0</span>) {</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a>            <span class="cf">break</span>;</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a>        }</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a>        printf(<span class="st">&quot;=&gt; %s</span><span class="sc">\n</span><span class="st">&quot;</span>, line);</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true"></a>        <span class="cf">if</span> (strncmp(line, <span class="st">&quot;exit&quot;</span>, <span class="dv">4</span>) == <span class="dv">0</span>) {</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true"></a>            run_loop = false;</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true"></a>        }</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true"></a>        numero += <span class="dv">1</span>;</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true"></a>    }</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true"></a>    printf(<span class="st">&quot;Bye!</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true"></a>    free(line);</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true"></a>    <span class="cf">return</span> EXIT_SUCCESS;</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true"></a>}</span></code></pre></div>
<p><strong>Remarques</strong> :</p>
<ol type="1">
<li>La détection de l’arrêt se fait de façon un peu sommaire, en regardant si les 4 caractères <code>exit</code> figurent au début de la ligne.</li>
<li>Le test <code>if (length &lt; 0)</code> détecte si l’utilisateur a fermé l’entrée standard en tapant <code>contrôle-D</code> dans la console.</li>
<li>Par mesure d’hygiène, on libère le tampon <code>line</code> à la fin du programme.</li>
</ol>
<h2 data-number="2.3" id="exemple-dexécution"><span class="header-section-number">2.3</span> Exemple d’exécution</h2>
<p>Si on fait tourner le programme, on remarque que <code>getline()</code> a aussi récupéré dans le tampon <code>line</code> le caractère de saut de ligne tapé par l’utilisateur. Ce qui fait afficher une ligne blanche.</p>
<pre><code>$ ./demo-boucle
-- Démo Boucle
tapez exit pour arrêter
1&gt; premiere ligne
=&gt; premiere ligne

2&gt; la seconde ligne
=&gt; la seconde ligne

3&gt; exit
=&gt; exit

Bye!</code></pre>
<h2 data-number="2.4" id="compilation-et-exécution"><span class="header-section-number">2.4</span> Compilation et exécution</h2>
<p>Le source a été compilé avec les options suivantes :</p>
<pre><code>gcc -std=c17 -Wall -Wextra -pedantic -Werror -Wno-unused \
    -D_XOPEN_SOURCE=700 \
    demo-boucle.c   -o demo-boucle</code></pre>
<p>qui permettent l’utilisation de la bibliothèque POSIX (= XOPEN).</p>
<h2 data-number="2.5" id="vérification-des-fuites-mémoires"><span class="header-section-number">2.5</span> Vérification des fuites mémoires</h2>
<p>On peut vérifier que ce programme n’a pas de fuite mémoire, en le lançant sous contrôle de <code>valgrind</code> :</p>
<pre><code>$ valgrind -s -q --leak-check=full ./demo-boucle
--- Démo Boucle
tapez exit pour arrêter
1&gt; une ligne 
=&gt; une ligne

2&gt; une seconde ligne
=&gt; une seconde ligne

3&gt; exit
=&gt; exit

Bye!
==8085== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</code></pre>
<p>Si vous mettez en commentaire la libération de <code>line</code>, vous obtiendrez un message du type</p>
<pre><code>==7873== 120 bytes in 1 blocks are definitely lost in loss record 1 of 1
==7873==    at 0x483877F: malloc (vg_replace_malloc.c:307)
==7873==    by 0x48D373F: getdelim (iogetdelim.c:62)
==7873==    by 0x1091D1: main (demo-boucle.c:18)
==7873== 
==7873== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)</code></pre>
<h1 data-number="3" id="seconde-étape-représenter-un-tableau-de-chaînes"><span class="header-section-number">3</span> Seconde étape : représenter un tableau de chaînes</h1>
<p>Notre programme devra découper la ligne qui est tapée par l’utilisateur. Par exemple, à partir de <code>&quot;ls -l /tmp&quot;</code>, il faudra obtenir un tableau contenant 3 chaînes <code>&quot;ls&quot;</code>, <code>&quot;-l&quot;</code> et <code>&quot;/tmp&quot;</code>.</p>
<p>Comme le langage C ne propose pas de conteneurs, on va réaliser nous même un type de données “tableau extensible de pointeurs”.</p>
<p>Ce type de données sera compilé séparément, il est</p>
<ul>
<li>décrit par un fichier d’en-tête <code>ptr-array.h</code>, avec une définition de structure <code>ptr_array</code>, et des fonctions qui agissent dessus (avec préfixe <code>pa_</code>)</li>
<li>implémenté dans <code>ptr-array.c</code>.</li>
</ul>
<p>On choisit de faire un tableau de pointeurs “génériques” (<code>void *</code>), parce que c’est plus général que de se spécialiser sur un tableau de pointeurs de caractères, et que ce n’est absolument pas plus compliqué.</p>
<p>Ça répond même à une question existentielle : si un tableau contient des chaînes, ces chaînes appartiennent-elles au tableau ? Autrement dit, faut-il les libérer quand on libère le tableau ?</p>
<p>Si on part comme ici sur la base d’un tableau de <em>pointeurs</em>, la réponse est clairement non. Quand le tableau disparaît, les pointeurs aussi, mais libérer les objets pointés, c’est pas la responsabilité du tableau.</p>
<p>C’est toujours une bonne idée de commencer par écrire des tests pour les modules que l’on réalise. Ça permet de voir de quoi on a besoin.</p>
<h2 data-number="3.1" id="code-des-tests-fonctionnalités-tests-ptr-array.c"><span class="header-section-number">3.1</span> Code des tests, fonctionnalités (<code>tests-ptr-array.c</code>)</h2>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="co">// tests-ptr-array.c</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;ptr-array.h&quot;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a><span class="dt">void</span> basic_test()</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>{</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>    printf(<span class="st">&quot;- basic_test()</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>    <span class="kw">struct</span> ptr_array sa = pa_new();</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>    assert(<span class="st">&quot;new PtrArray size is zero&quot;</span> &amp;&amp;</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>           pa_size(&amp;sa) == <span class="dv">0</span>);</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a>    <span class="dt">char</span> *s[<span class="dv">21</span>] = {</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a>        <span class="st">&quot;zero&quot;</span>, <span class="st">&quot;one&quot;</span>, <span class="st">&quot;two&quot;</span>, <span class="st">&quot;three&quot;</span>, <span class="st">&quot;four&quot;</span>,</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true"></a>        <span class="st">&quot;five&quot;</span>, <span class="st">&quot;six&quot;</span>, <span class="st">&quot;seven&quot;</span>, <span class="st">&quot;eight&quot;</span>, <span class="st">&quot;nine&quot;</span>,</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true"></a>        <span class="st">&quot;ten&quot;</span>, <span class="st">&quot;eleven&quot;</span>, <span class="st">&quot;twelve&quot;</span>, <span class="st">&quot;thirteen&quot;</span>, <span class="st">&quot;fourteen&quot;</span>,</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true"></a>        <span class="st">&quot;fifteen&quot;</span>, <span class="st">&quot;sixteen&quot;</span>, <span class="st">&quot;seventeen&quot;</span>, <span class="st">&quot;eighteen&quot;</span>, <span class="st">&quot;nineteen&quot;</span>,</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true"></a>        <span class="st">&quot;twenty&quot;</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true"></a>    };</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true"></a></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; <span class="dv">21</span>; i++) {</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true"></a>        pa_add(&amp;sa, s[i]);</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true"></a>        assert(<span class="st">&quot;adding increases size&quot;</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true"></a>               &amp;&amp; pa_size(&amp;sa) == i+<span class="dv">1</span>);</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true"></a>        assert(<span class="st">&quot;data is present at end&quot;</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true"></a>               &amp;&amp; pa_get(&amp;sa, i) == s[i]);</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true"></a>    }</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true"></a></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; <span class="dv">21</span>; i++) {</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true"></a>        assert(<span class="st">&quot;all added data is there&quot;</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true"></a>               &amp;&amp; pa_get(&amp;sa, i) == s[i]);</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true"></a>    }</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true"></a></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true"></a>    pa_delete(&amp;sa);</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true"></a></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true"></a>}</span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true"></a></span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true"></a>{</span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true"></a>    printf(<span class="st">&quot;# Tests ptr_array</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true"></a>    basic_test();</span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true"></a>    printf(<span class="st">&quot;Ok</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true"></a>}</span></code></pre></div>
<p>Les fonctionnalités testées :</p>
<ul>
<li><code>pa_new()</code> : retourne un tableau de pointeurs initialisé à vide ;</li>
<li><code>pa_size()</code> : indique le nombre de pointeurs présents dans le tableau ;</li>
<li><code>pa_add()</code> : ajoute un pointeur à la fin du tableau ;</li>
<li><code>pa_get()</code> : retourne le n-ième pointeur (indices à partir de 0) ;</li>
<li><code>pa_delete()</code> : libère le contenu d’un tableau de pointeurs.</li>
</ul>
<p>En gros le test</p>
<ul>
<li>initialise un tableau (vide),</li>
<li>vérifie que sa taille est 0,</li>
<li>y ajoute 21 pointeurs en vérifiant à chaque étape
<ul>
<li>que la taille a augmenté</li>
<li>que l’élément ajouté est présent à la fin</li>
</ul></li>
<li>puis vérifie que les 21 éléments sont présents à leur place.</li>
</ul>
<h2 data-number="3.2" id="fichier-den-tête-ptr-array.h"><span class="header-section-number">3.2</span> Fichier d’en-tête <code>ptr-array.h</code></h2>
<p>Un “<code>ptr_array</code>” est matérialisé par une structure contenant</p>
<ul>
<li><code>array</code> : un tableau de pointeurs, alloué dynamiquement, et qui sera ré-alloué quand on aura besoin de l’agrandir ;</li>
<li><code>capacity</code> : le nombre de pointeurs que peut contenir le tableau alloué ;</li>
<li><code>size</code> : le nombre de pointeurs utilisés pour l’instant.</li>
</ul>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="co">// ptr-array.h </span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="pp">#ifndef PTR_ARRAY_H</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="pp">#define PTR_ARRAY_H</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stddef.h&gt;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a><span class="kw">struct</span> ptr_array {</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>    <span class="dt">size_t</span> size;</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>    <span class="dt">size_t</span> capacity;</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>    <span class="dt">void</span> **array;</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>};</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a><span class="dt">void</span> pa_init(<span class="kw">struct</span> ptr_array *pa); </span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a><span class="kw">struct</span> ptr_array pa_new();</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a><span class="dt">void</span> pa_delete(<span class="kw">struct</span> ptr_array *pa);</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true"></a><span class="dt">void</span> pa_add(<span class="kw">struct</span> ptr_array *pa, <span class="dt">void</span> *ptr);</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true"></a></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true"></a><span class="dt">size_t</span> pa_size(<span class="dt">const</span> <span class="kw">struct</span> ptr_array *pa);</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true"></a><span class="dt">void</span> * pa_get(<span class="dt">const</span> <span class="kw">struct</span> ptr_array *pa, <span class="dt">size_t</span> index);</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true"></a></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true"></a><span class="pp">#endif</span></span></code></pre></div>
<p><strong>Remarques</strong></p>
<ul>
<li>On a utilisé <code>const</code> autant que possible, pour les fonctions qui reçoivent l’adresse d’un objet qu’elles ne sont pas censées modifier.</li>
<li>La fonction <code>pa_new()</code> semble faire double emploi avec <code>pa_init()</code> : en fait elle permet de combiner élégamment définition et initialisation d’un tableau, comme dans</li>
</ul>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">struct</span> ptr_array sa = pa_new();</span></code></pre></div>
<h2 data-number="3.3" id="implémentation-des-fonctions-ptr-array.c"><span class="header-section-number">3.3</span> Implémentation des fonctions <code>ptr-array.c</code></h2>
<p>C’est une implémentation classique d’un tableau extensible</p>
<ul>
<li>lors de son initialisation, sa capacité est fixée à un petit nombre d’éléments (ici 8 pointeurs);</li>
<li>quand il est plein et qu’on veut ajouter un élément supplémentaire, la capacité est doublée par réallocation.</li>
</ul>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="co">// ptr-array.c</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;memory.h&gt;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;ptr-array.h&quot;</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a><span class="pp">#ifndef PTR_ARRAY_MIN_CAPACITY</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>    <span class="pp">#define PTR_ARRAY_MIN_CAPACITY 8</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a><span class="pp">#endif</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a><span class="kw">struct</span> ptr_array pa_new() {</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true"></a>    <span class="cf">return</span> (<span class="kw">struct</span> ptr_array) {</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true"></a>        .size = <span class="dv">0</span>,</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true"></a>        .capacity = PTR_ARRAY_MIN_CAPACITY,</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true"></a>        .array = malloc(PTR_ARRAY_MIN_CAPACITY</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true"></a>                        * <span class="kw">sizeof</span>(<span class="dt">void</span> *))</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true"></a>    };</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true"></a>}</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true"></a></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true"></a><span class="dt">void</span> pa_init(<span class="kw">struct</span> ptr_array *pa)</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true"></a>{</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true"></a>    *pa = pa_new();</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true"></a>}</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true"></a></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true"></a><span class="dt">void</span> pa_delete(<span class="kw">struct</span> ptr_array *pa)</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true"></a>{</span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true"></a>    pa-&gt;size = <span class="dv">0</span>;</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true"></a>    pa-&gt;capacity = <span class="dv">0</span>;</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true"></a>    free(pa-&gt;array);</span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true"></a>    pa-&gt;array = NULL;</span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true"></a>}</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true"></a></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true"></a><span class="dt">void</span> pa_add(<span class="kw">struct</span> ptr_array *pa, <span class="dt">void</span> *ptr)</span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true"></a>{</span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true"></a>    <span class="cf">if</span> (pa-&gt;size == pa-&gt;capacity) {</span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true"></a>        pa-&gt;capacity *= <span class="dv">2</span>;</span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true"></a>        pa-&gt;array = realloc(pa-&gt;array,</span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true"></a>                            pa-&gt;capacity * <span class="kw">sizeof</span>(<span class="dt">void</span> *);</span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true"></a>    }</span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true"></a>    pa-&gt;array[pa-&gt;size++] = ptr;</span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true"></a>}</span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true"></a></span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true"></a><span class="dt">size_t</span> pa_size(<span class="dt">const</span> <span class="kw">struct</span> ptr_array *pa)</span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true"></a>{</span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true"></a>    <span class="cf">return</span> pa-&gt;size;</span>
<span id="cb9-47"><a href="#cb9-47" aria-hidden="true"></a>}</span>
<span id="cb9-48"><a href="#cb9-48" aria-hidden="true"></a></span>
<span id="cb9-49"><a href="#cb9-49" aria-hidden="true"></a><span class="dt">void</span> * pa_get(<span class="dt">const</span> <span class="kw">struct</span> ptr_array *pa, <span class="dt">size_t</span> index)</span>
<span id="cb9-50"><a href="#cb9-50" aria-hidden="true"></a>{</span>
<span id="cb9-51"><a href="#cb9-51" aria-hidden="true"></a>    <span class="cf">return</span> pa-&gt;array[index];</span>
<span id="cb9-52"><a href="#cb9-52" aria-hidden="true"></a>}</span></code></pre></div>
<p>Ceci garantit que le coût amorti moyen d’un ajout est élémentaire O(1).</p>
<p>Pour ceux qui ne sont pas familiers avec ces notions</p>
<ul>
<li>les ré-allocations se produisent quand on arrive à 8+1, 16+1, 32+1, etc.</li>
<li>quand on arrive par exemple à 1024+1, en tout on aura eu des allocations de 8, 16, 32, … 1024 et 2048.</li>
<li>le coût d’une ré-allocation est proportionnel à sa taille (il faut recopier l’ancien contenu)</li>
<li>le coût total est donc de 8+16+…+2048, ce qui fait un peu moins de 4096, pour 1024+1 à 2048 éléments.</li>
<li>donc le coût moyen par élément est entre 4096/2048 et 4096/1024, c’est à dire entre 2 et 4.</li>
</ul>
<p><strong>Remarques :</strong></p>
<ul>
<li><p>noter, dans <code>pa_new()</code>, le retour d’une structure anonyme ;</p></li>
<li><p>dans le test, on a choisi d’ajouter 21 éléments pour que se produisent</p>
<ul>
<li>l’allocation initiale de 8 pointeurs,</li>
<li>le passage à 16 lors du 9-ième ajout,</li>
<li>le passage à 32 lors du 17-ième ajout.</li>
</ul></li>
</ul>
<h2 data-number="3.4" id="compilation-et-exécution-des-tests"><span class="header-section-number">3.4</span> Compilation et exécution des tests</h2>
<p>On effectue une compilation séparée</p>
<pre><code>$ gcc -std=c17 -Wall -Wextra -pedantic -Werror -Wno-unused -MMD -D_XOPEN_SOURCE=700 -g   -c -o ptr-array.o ptr-array.c

$ gcc -std=c17 -Wall -Wextra -pedantic -Werror -Wno-unused -MMD -D_XOPEN_SOURCE=700 -g   -c -o tests-ptr-array.o tests-ptr-array.c

$ gcc -std=c17 -Wall -Wextra -pedantic -Werror -Wno-unused -MMD -D_XOPEN_SOURCE=700 -g    tests-ptr-array.c ptr-array.o ptr-array.h   -o tests-ptr-array</code></pre>
<p>Les tests se déroulent sans erreurs, et ne montrent pas de fuite mémoire :</p>
<pre><code>$ valgrind -s -q --leak-check=full ./ptr_array
# Tests ptr_array
- basic_test()
Ok
==8680== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</code></pre>
<h1 data-number="4" id="troisième-étape-découpage-de-la-ligne"><span class="header-section-number">4</span> Troisième étape : découpage de la ligne</h1>
<p>Ici aussi nous commençons par les tests.</p>
<p>Ce que nous voulons c’est une fonction <code>split_line()</code> qui</p>
<ul>
<li>reçoit une chaîne de caractères</li>
<li>retourne une structure <code>split_line_result</code> contenant
<ul>
<li>dans le champ <code>strings</code> le tableau de chaînes résultant du découpage de la ligne,</li>
<li>des indications sur d’éventuelles erreurs de syntaxe.</li>
</ul></li>
</ul>
<p>On ne les utilisera pas ici, mais les erreurs pourraient être des guillemets manquants etc. dans une version plus réaliste d’un shell.</p>
<h2 data-number="4.1" id="tests-du-découpage-test-split-line.c"><span class="header-section-number">4.1</span> Tests du découpage (<code>test-split-line.c</code>)</h2>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="co">// test-split-line.c</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;split-line.h&quot;</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a><span class="dt">void</span> test_empty(<span class="dt">const</span> <span class="dt">char</span> line[])</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a>{</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true"></a>    <span class="kw">struct</span> split_line_result r = split_line(line);</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true"></a>    assert(<span class="st">&quot;empty line has no words&quot;</span> &amp;&amp;</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true"></a>           pa_size(&amp; r.strings) == <span class="dv">0</span>);</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true"></a>    split_line_result_delete(&amp; r);</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true"></a>}</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true"></a></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true"></a><span class="dt">void</span> basic_test()</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true"></a>{</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true"></a>    printf(<span class="st">&quot;- basic_test()</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true"></a>    <span class="dt">char</span> line[] = <span class="st">&quot;  one  two three&quot;</span>;</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true"></a>    <span class="kw">struct</span> split_line_result r = split_line(line);</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true"></a>    assert(<span class="st">&quot;example size is 3&quot;</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true"></a>           &amp;&amp; pa_size(&amp;r.strings) == <span class="dv">3</span>);</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true"></a>    assert(<span class="st">&quot;first word is &#39;one&#39;&quot;</span> &amp;&amp;</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true"></a>            strcmp(pa_get(&amp;r.strings, <span class="dv">0</span>), <span class="st">&quot;one&quot;</span>) == <span class="dv">0</span>);</span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true"></a>    assert(<span class="st">&quot;second word is &#39;two&#39;&quot;</span> &amp;&amp;</span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true"></a>            strcmp(pa_get(&amp;r.strings, <span class="dv">1</span>), <span class="st">&quot;two&quot;</span>) == <span class="dv">0</span>);</span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true"></a>    assert(<span class="st">&quot;third word is &#39;three&#39;&quot;</span> &amp;&amp;</span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true"></a>            strcmp(pa_get(&amp;r.strings, <span class="dv">2</span>), <span class="st">&quot;three&quot;</span>) == <span class="dv">0</span>);</span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true"></a>    split_line_result_delete(&amp; r);</span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true"></a></span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true"></a>}</span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true"></a></span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true"></a><span class="dt">void</span> test_empty_lines()</span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true"></a>{</span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true"></a>    printf(<span class="st">&quot;- test_empty_lines()</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true"></a>    test_empty(<span class="st">&quot;&quot;</span>);</span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true"></a>    test_empty(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true"></a>    test_empty(<span class="st">&quot;    </span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true"></a>}</span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true"></a></span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true"></a>{</span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true"></a>    printf(<span class="st">&quot;# tests split-line</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true"></a>    test_empty_lines();</span>
<span id="cb12-48"><a href="#cb12-48" aria-hidden="true"></a>    basic_test();</span>
<span id="cb12-49"><a href="#cb12-49" aria-hidden="true"></a>    printf(<span class="st">&quot;Ok</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb12-50"><a href="#cb12-50" aria-hidden="true"></a>}</span></code></pre></div>
<p>Comme on le voit, il y a</p>
<ul>
<li>des tests sur différentes formes de lignes vides (avec des espaces, des sauts de ligne),</li>
<li>une vérification du découpage d’une ligne de 3 mots.</li>
</ul>
<p>La fonction <code>split_line_result_delete()</code> est chargé de libérer les ressources contenues dans une structure <code>split_line_result</code>.</p>
<h2 data-number="4.2" id="le-fichier-dentête-split-line.h"><span class="header-section-number">4.2</span> Le fichier d’entête (<code>split-line.h</code>)</h2>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="co">// split-line.h</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a><span class="pp">#ifndef SPLIT_LINE_H</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a><span class="pp">#define SPLIT_LINE_H</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;ptr-array.h&quot;</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a><span class="kw">struct</span> split_line_result {</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>    <span class="kw">struct</span> ptr_array strings;</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a>    <span class="dt">const</span> <span class="dt">char</span> *error_message;</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a>    <span class="dt">size_t</span> error_position;</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a>};</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true"></a><span class="kw">struct</span> split_line_result split_line(<span class="dt">const</span> <span class="dt">char</span> line[]);</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true"></a><span class="dt">void</span> split_line_result_delete(<span class="kw">struct</span> split_line_result *r);</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true"></a></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true"></a><span class="pp">#endif</span></span></code></pre></div>
<h2 data-number="4.3" id="le-code-du-découpage-split-line.c"><span class="header-section-number">4.3</span> Le code du découpage (<code>split-line.c</code>)</h2>
<p>Ici on se contente d’un découpage très sommaire : on considère que la ligne se décompose en mots qui étaient séparés par des espaces.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="co">// split-line.c</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;malloc.h&gt;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;ctype.h&gt;</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;split-line.h&quot;</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a><span class="dt">static</span> <span class="dt">bool</span> is_ending_char(<span class="dt">char</span> c)</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a>{</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a>    <span class="cf">return</span> (c == <span class="ch">&#39;#&#39;</span>) || (c == <span class="ch">&#39;\0&#39;</span>);</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true"></a>}</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true"></a></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true"></a><span class="dt">static</span> <span class="dt">bool</span> is_word_char(<span class="dt">char</span> c)</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true"></a>{</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true"></a>    <span class="cf">return</span> !( isspace(c) || is_ending_char(c));</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true"></a>}</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true"></a></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true"></a><span class="kw">struct</span> split_line_result split_line(<span class="dt">const</span> <span class="dt">char</span> line[])</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true"></a>{</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true"></a>    <span class="kw">struct</span> split_line_result r = {</span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true"></a>        .error_message = NULL,</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true"></a>        .error_position = <span class="dv">0</span>,</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true"></a>        .strings = pa_new()</span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true"></a>    };</span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true"></a></span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true"></a>    <span class="dt">int</span> i = <span class="dv">0</span>;</span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true"></a></span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true"></a>    <span class="cf">for</span> (;;) {</span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true"></a>        <span class="co">// ignore spaces</span></span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true"></a>        <span class="cf">while</span>(isspace(line[i])) {</span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true"></a>            i++;</span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true"></a>        };</span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true"></a>        <span class="cf">if</span> (is_ending_char(line[i])) {</span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true"></a>            <span class="cf">break</span>;</span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true"></a>        }</span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true"></a>        <span class="dt">int</span> start_index = i;</span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true"></a>        <span class="cf">do</span> {</span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true"></a>            i += <span class="dv">1</span>;</span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true"></a>        } <span class="cf">while</span>(is_word_char(line[i]));</span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true"></a></span>
<span id="cb14-43"><a href="#cb14-43" aria-hidden="true"></a>        pa_add(&amp; r.strings,</span>
<span id="cb14-44"><a href="#cb14-44" aria-hidden="true"></a>               strndup(&amp; line[start_index], </span>
<span id="cb14-45"><a href="#cb14-45" aria-hidden="true"></a>                       i - start_index));</span>
<span id="cb14-46"><a href="#cb14-46" aria-hidden="true"></a>    }</span>
<span id="cb14-47"><a href="#cb14-47" aria-hidden="true"></a></span>
<span id="cb14-48"><a href="#cb14-48" aria-hidden="true"></a>    <span class="cf">return</span> r;</span>
<span id="cb14-49"><a href="#cb14-49" aria-hidden="true"></a>}</span>
<span id="cb14-50"><a href="#cb14-50" aria-hidden="true"></a></span>
<span id="cb14-51"><a href="#cb14-51" aria-hidden="true"></a><span class="dt">void</span> split_line_result_delete(<span class="kw">struct</span> split_line_result *r)</span>
<span id="cb14-52"><a href="#cb14-52" aria-hidden="true"></a>{</span>
<span id="cb14-53"><a href="#cb14-53" aria-hidden="true"></a>    <span class="dt">const</span> <span class="dt">size_t</span> n = pa_size(&amp; r-&gt;strings);</span>
<span id="cb14-54"><a href="#cb14-54" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; n; i++) {</span>
<span id="cb14-55"><a href="#cb14-55" aria-hidden="true"></a>        free(pa_get(&amp; r-&gt;strings, i));</span>
<span id="cb14-56"><a href="#cb14-56" aria-hidden="true"></a>    }</span>
<span id="cb14-57"><a href="#cb14-57" aria-hidden="true"></a>    pa_delete(&amp; r-&gt;strings);</span>
<span id="cb14-58"><a href="#cb14-58" aria-hidden="true"></a>}</span></code></pre></div>
<p><strong>Explications :</strong></p>
<ol type="1">
<li><p>La boucle <code>for</code> de <code>split_line()</code> remplit un tableau de chaînes :</p>
<ul>
<li>elle repère le premier caractère non-blanc,</li>
<li>s’arrête si on est arrivé au bout (fin de la ligne, ou début d’un commentaire),</li>
<li>cherche la fin du mot,</li>
<li>ajoute une copie du mot dans le tableau par <code>strndup()</code> - qui fait partie de la bibliothèque POSIX -,</li>
<li>et recommence.</li>
</ul></li>
<li><p>Comme <code>strndup()</code> alloue dynamiquement des chaînes, la fonction <code>split_line_result_delete()</code> s’occupera de les libérer, avant de libérer le tableau de pointeurs lui-même.</p></li>
</ol>
<h1 data-number="5" id="lexécution-des-commandes"><span class="header-section-number">5</span> L’exécution des commandes</h1>
<p>La fonction <code>main()</code> du programme final est similaire à ce qui a été vu au début de ce document, si ce n’est qu’elle va</p>
<ul>
<li>appeler <code>split_line()</code> pour découper la ligne</li>
<li>afficher un message si il y a eu une erreur de syntaxe dans la ligne tapée,</li>
<li>sinon appeler une fonction <code>execute_command()</code> en lui donnant le tableau des mots de la ligne, ce qui nous fournira un résultat de type <code>struct command_result</code>. qui indique comment la commande s’est déroulée.</li>
</ul>
<h2 data-number="5.1" id="la-structure-command_result"><span class="header-section-number">5.1</span> La structure <code>command_result</code></h2>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">struct</span> command_result {</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>    <span class="dt">bool</span> exit_shell;</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>    <span class="dt">int</span>  status;</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>    <span class="dt">int</span>  errnum;</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>};</span></code></pre></div>
<ul>
<li><code>exit_shell</code> est un booléen qui dit si il faut arrêter la boucle,</li>
<li><code>status</code> sera la valeur retournée par l’<code>exit()</code> du <code>main()</code>;</li>
<li><code>errnum</code> contient le “<code>errno</code>” qui est positionné par les commandes système. Il nous servira à afficher le message d’erreur approprié.</li>
</ul>
<h2 data-number="5.2" id="la-fonction-main"><span class="header-section-number">5.2</span> La fonction <code>main()</code></h2>
<p>La fonction <code>main()</code> effectue la boucle de dialogue. avec l’utilisateur, et le traitement de la ligne tapée :</p>
<ul>
<li>découpage de la ligne</li>
<li>affichage éventuel d’un message en cas d’erreur</li>
<li>appel de la fonction <code>execute_command()</code></li>
<li>affichage éventuel de message d’erreur si</li>
</ul>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="pp">#define SHELL_NAME &quot;Mini Shell V1.1&quot;</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>{</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>    <span class="dt">char</span> *line = NULL;</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a>    <span class="dt">size_t</span> line_size = <span class="dv">0</span>;</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a>    printf(<span class="st">&quot;--- Hello, this is &quot;</span> SHELL_NAME <span class="st">&quot;!</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true"></a>    <span class="dt">int</span> numero = <span class="dv">1</span>;</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">bool</span> run_loop = true; run_loop; ) {</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true"></a>        printf(<span class="st">&quot;%d&gt; &quot;</span>, numero);</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true"></a>        <span class="dt">int</span> length = getline(&amp; line, &amp;line_size, stdin);</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true"></a>        <span class="cf">if</span> (length &lt; <span class="dv">0</span>) {</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true"></a>            <span class="cf">break</span>;</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true"></a>        }</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true"></a>        <span class="kw">struct</span> split_line_result slr = split_line(line);</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true"></a>        <span class="cf">if</span> (slr.error_message != NULL) {</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true"></a>            printf(<span class="st">&quot;Syntax Error at char %zu: %s</span><span class="sc">\n</span><span class="st">&quot;</span>,</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true"></a>                   slr.error_position, slr.error_message);</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true"></a>        } <span class="cf">else</span> {</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true"></a>            <span class="cf">if</span> (pa_size(&amp; slr.strings) != <span class="dv">0</span>) {</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true"></a>                <span class="kw">struct</span> command_result cr = execute_command(&amp; slr.strings);</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true"></a>                numero += <span class="dv">1</span>;  <span class="co">// doesn&#39;t advance if empty command</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true"></a>                <span class="cf">if</span> (cr.errnum != <span class="dv">0</span>) {</span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true"></a>                    printf(<span class="st">&quot;Error: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, strerror(cr.errnum));</span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true"></a>                }</span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true"></a>                <span class="cf">if</span> (cr.exit_shell) {</span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true"></a>                    run_loop = false;</span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true"></a>                }</span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true"></a>            }</span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true"></a>        }</span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true"></a>        split_line_result_delete(&amp; slr);</span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true"></a>    }</span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true"></a></span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true"></a>    printf(<span class="st">&quot;Bye!</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true"></a>    free(line);</span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true"></a>    <span class="cf">return</span> EXIT_SUCCESS;</span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true"></a>}</span></code></pre></div>
<h2 data-number="5.3" id="les-commandes-internes"><span class="header-section-number">5.3</span> Les commandes internes</h2>
<p>Les fonctions qui exécutent les commandes ont le même prototype que <code>execute_command()</code></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>/ ------------------------------------------</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a><span class="co">// internal commands</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a><span class="co">//</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a><span class="kw">struct</span> command_result execute_internal_exit(</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>    <span class="dt">const</span> <span class="kw">struct</span> ptr_array *args)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>{</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a>    <span class="dt">int</span> status = pa_size(args) == <span class="dv">1</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a>                  ? <span class="dv">0</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true"></a>                  : atoi(pa_get(args, <span class="dv">1</span>));</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true"></a>    <span class="cf">return</span> (<span class="kw">struct</span> command_result) {</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true"></a>        .exit_shell = true,</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true"></a>        .status = status,</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true"></a>        .errnum = <span class="dv">0</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true"></a>    };</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true"></a>}</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true"></a></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true"></a><span class="kw">struct</span> command_result execute_internal_cd(</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true"></a>    <span class="dt">const</span> <span class="kw">struct</span> ptr_array *args)</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true"></a>{</span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true"></a>    <span class="dt">char</span> *dest = pa_size(args) == <span class="dv">1</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true"></a>                 ? getenv(<span class="st">&quot;HOME&quot;</span>)</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true"></a>                 : pa_get(args, <span class="dv">1</span>);</span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true"></a>    <span class="dt">int</span> status = chdir(dest);</span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true"></a>    <span class="cf">return</span> (<span class="kw">struct</span> command_result) {</span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true"></a>        .exit_shell = false,</span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true"></a>        .status = status,</span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true"></a>        .errnum = errno</span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true"></a>    };</span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true"></a>}</span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true"></a></span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true"></a><span class="kw">struct</span> command_result execute_internal_help(</span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true"></a>    <span class="dt">const</span> <span class="kw">struct</span> ptr_array *args)</span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true"></a>{</span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true"></a>    printf(<span class="st">&quot;Commands: </span><span class="sc">\n</span><span class="st">&quot;</span></span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true"></a>           <span class="st">&quot;</span><span class="sc">\t</span><span class="st">exit [value] leave the shell</span><span class="sc">\n</span><span class="st">&quot;</span></span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true"></a>           <span class="st">&quot;</span><span class="sc">\t</span><span class="st">cd  [dir]     change current directory (default: home)</span><span class="sc">\n</span><span class="st">&quot;</span></span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true"></a>           <span class="st">&quot;</span><span class="sc">\t</span><span class="st">help  | ?     this message</span><span class="sc">\n</span><span class="st">&quot;</span></span>
<span id="cb17-39"><a href="#cb17-39" aria-hidden="true"></a>          );</span>
<span id="cb17-40"><a href="#cb17-40" aria-hidden="true"></a>    <span class="cf">return</span> (<span class="kw">struct</span> command_result) {</span>
<span id="cb17-41"><a href="#cb17-41" aria-hidden="true"></a>        .exit_shell = false,</span>
<span id="cb17-42"><a href="#cb17-42" aria-hidden="true"></a>        .status = EXIT_SUCCESS,</span>
<span id="cb17-43"><a href="#cb17-43" aria-hidden="true"></a>        .errnum = <span class="dv">0</span></span>
<span id="cb17-44"><a href="#cb17-44" aria-hidden="true"></a>    };</span>
<span id="cb17-45"><a href="#cb17-45" aria-hidden="true"></a>}</span></code></pre></div>
<p><strong>Commentaires</strong></p>
<ul>
<li>la commande interne “exit” a un paramètre optionnel qui est une valeur à retourner (par défaut 0). Elle positionne l’indicateur de sortie.</li>
<li>la commande “cd” a un paramètre optionnel, le chemin du répertoire destination (par défaut le répertoire d’accueil qui est indiqué dans la variable d’environnment <code>HOME</code>). L’appel système <code>chdir</code> pouvant échouer, le code de retour et le numéro d’erreur sont rapportés à l’appelant.</li>
<li>la commande “help” affiche juste quelques messages.</li>
<li>on ne fait guère d’effort pour s’occuper des paramètres excédentaires !</li>
</ul>
<h2 data-number="5.4" id="la-fonction-execute_command"><span class="header-section-number">5.4</span> La fonction <code>execute_command()</code></h2>
<p>Cette fonction doit déterminer si le premier mot est le nom d’une des commandes internes, et</p>
<ul>
<li>si oui lancer la fonction qui s’en occupe,</li>
<li>sinon il s’agit de faire exécuter un programme (commande externe).</li>
</ul>
<p>Comme un shell possède de nombreuses commandes internes, on évite de coder une série de tests emboîtés, au profit d’une table de correspondance entre des noms de commandes, et des pointeurs vers les fonctions qui s’en occupent :</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="co">// -----------------------------------------------------</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a><span class="co">// table of internal commands :</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a><span class="co">// </span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">struct</span> command_result (*FUNCTION)(</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a>    <span class="dt">const</span> <span class="kw">struct</span> ptr_array *</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a>);</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a><span class="kw">struct</span> {</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true"></a>    <span class="dt">const</span> <span class="dt">char</span> *name;</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true"></a>    FUNCTION function;</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true"></a>} commands_table[] = {</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true"></a>    {<span class="st">&quot;exit&quot;</span>, &amp;execute_internal_exit},</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true"></a>    {<span class="st">&quot;cd&quot;</span>, &amp;execute_internal_cd},</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true"></a>    {<span class="st">&quot;help&quot;</span>, &amp;execute_internal_help},</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true"></a>    {<span class="st">&quot;?&quot;</span>, &amp;execute_internal_help},</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true"></a></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true"></a>    {NULL, NULL}</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true"></a>};</span></code></pre></div>
<p>qui sera beaucoup plus facile à maintenir (et permet des synonymes, commme <code>&quot;?&quot;</code> pour <code>&quot;help&quot;</code>).</p>
<p>La fonction <code>execute_command()</code></p>
<ul>
<li>cherche dans cette table la fonction qui correspond au premier mot de la ligne</li>
<li>l’exécute en lui passant les paramètres.</li>
</ul>
<p>Si le nom n’y figure pas, il s’agit d’une commande externe, qui sera traitée par la fonction <code>execute_external_command</code> (voir plus loin)</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="kw">struct</span> command_result execute_command(</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>    <span class="kw">struct</span> ptr_array *args</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>{</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>    <span class="dt">const</span> <span class="dt">char</span> * name = pa_get(args, <span class="dv">0</span>);</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a>    FUNCTION function = &amp;execute_external_command;</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; commands_table[i].name != NULL; i++) {</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a>        <span class="cf">if</span> (strcmp(commands_table[i].name, name) == <span class="dv">0</span>) {</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true"></a>            <span class="co">// internal command found</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true"></a>            function = commands_table[i].function;</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true"></a>            <span class="cf">break</span>;</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true"></a>        }</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true"></a>    }</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true"></a>    <span class="co">// apply function to args</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true"></a>    <span class="cf">return</span> (*function)(args);</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true"></a>}</span></code></pre></div>
<h2 data-number="5.5" id="lancement-dun-programme-par-execute_external_command"><span class="header-section-number">5.5</span> Lancement d’un programme par <code>execute_external_command()</code></h2>
<p>Pour exécuter une commande externe, le shell</p>
<ul>
<li>crée un processus fils qui appelle <code>execvp()</code> en lui donnant en paramètre un tableau de chaines avec le nom de l’exécutable et les arguments, suivis par un pointeur nul.</li>
<li>attend la fin de ce processus fils</li>
<li>retourne le status renvoyé par le processus fils.</li>
</ul>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="kw">struct</span> command_result execute_external_command(</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>    <span class="dt">const</span> <span class="kw">struct</span> ptr_array *args</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a>)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>{</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>    pid_t child_pid = fork();</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a>    <span class="cf">if</span> (child_pid == <span class="dv">0</span>) {</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a>        <span class="co">// build array</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a>        <span class="dt">size_t</span> nb_args = pa_size(args);</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true"></a>        <span class="dt">char</span> **a = malloc(<span class="kw">sizeof</span>(<span class="dt">char</span> *)</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true"></a>                          * (nb_args + <span class="dv">1</span>));</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true"></a>        <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; nb_args; i++) {</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true"></a>            a[i] = pa_get(args, i);</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true"></a>        }</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true"></a>        a[nb_args] = NULL;</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true"></a>        execvp(a[<span class="dv">0</span>], a);</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true"></a>        </span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true"></a>        <span class="co">// if failed</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true"></a>        perror(<span class="st">&quot;execvp failed&quot;</span>);</span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true"></a>        exit (EXIT_FAILURE);</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true"></a>    }</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true"></a>    <span class="dt">int</span> wait_status;</span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true"></a>    waitpid(child_pid, &amp;wait_status, <span class="dv">0</span>);</span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true"></a>    <span class="cf">return</span> (<span class="kw">struct</span> command_result) {</span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true"></a>        .exit_shell = false,</span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true"></a>        .errnum = <span class="dv">0</span>,</span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true"></a>        .status = WEXITSTATUS(wait_status)</span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true"></a>    };</span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true"></a>}</span></code></pre></div>
<p><strong>Appels système utilisés :</strong></p>
<ul>
<li><code>fork()</code> crée un processus “fils” qui est une copie de celui qui l’appelle (= père). Il retourne 0 au fils, et le numéro du fils au père.</li>
<li><code>exit()</code> termine le processus qui l’appelle.</li>
<li><code>waitpid</code> bloque un processus (ici le père) en attente de la fin d’un autre dont on donne le numéro (ici le fils).</li>
<li><code>execvp()</code> tente de remplacer le processus courant par l’exécution d’un programme en lui transmettant des arguments. L’exit du programme terminera le processus. En cas d’échec de lancement (fichier absent, non exécutable, etc) l’appelant continue.</li>
</ul>
<p><strong>Compléments :</strong></p>
<ul>
<li>il existe une famille de fonctions “<code>exec</code>”.
<ul>
<li><code>execv</code> prend comme paramètre le <strong>chemin d’accès</strong> de l’exécutable et un tableau de paramètres ;</li>
<li>celle de l’exemple (<code>execvp</code>) prend comme paramètre un <strong>nom de commande</strong> et un tableau de paramètres. L’exécutable est cherché dans les répertoires indiqués par la variable d’environnement <code>PATH</code>.</li>
<li>Voir aussi <code>execl</code> et <code>execlp</code> qui utilisent une <strong>liste</strong> de paramètres au lieu d’un <strong>tableau</strong>.</li>
</ul></li>
<li>ici on n’a utilisé que le premier paramètre de <code>waitpid</code>.
<ul>
<li>le troisième permet d’attendre un <strong>changement d’état</strong> du processus fils (pas seulement sa fin).</li>
<li>Le second, si il n’est pas <code>NULL</code>, est l’adresse d’un entier qui permettra par exemple de récupérer le code laissé par l’<code>exit</code> du processus fils. Voir la page de manuel.</li>
</ul></li>
</ul>
<h1 data-number="6" id="exemple-dexécution-1"><span class="header-section-number">6</span> Exemple d’exécution</h1>
<pre><code>$ ./mini-shell 
--- Hello, this is Mini Shell V1.1!
1&gt; ls
demo-boucle.c  ptr-array.h      tests-ptr-array.c
Makefile       ptr-array.o      tests-ptr-array.d
mini-shell     split-line.c     tests-split-line
mini-shell.c   split-line.d     tests-split-line.c
mini-shell.d   split-line.h     tests-split-line.d
ptr-array.c    split-line.o
ptr-array.d    tests-ptr-array
2&gt; help
Commands: 
        exit [value] leave the shell
        cd  [dir]     change current directory (default: home)
        help  | ?     this message
3&gt; cd 
4&gt; pwd
/home/billaud
5&gt; cd /tmp  
6&gt; pwd
/tmp
7&gt; exit 123
Bye!

$ echo $?
123</code></pre>
<p>La dernière commande montre que le status donné en argument dans notre mini-shell a bien été transmis.</p>
<h1 data-number="7" id="conclusion"><span class="header-section-number">7</span> Conclusion</h1>
<p>On a présenté ici la construction d’un mini-shell très rudimentaire avec possibilités de lancer des commandes externes, et quelques fonctions internes.</p>
<p>Dans un vrai shell, il y a des variables, des boucles, des redirections, de la gestion des processus etc. On en est très loin. Il ne faut pas cacher que ça ne serait pas facile, ne serait ce qu’en raison de la syntaxe étrange des langages de commande habituels.</p>
<p>L’important ici est la construction à partir d’un découpage en modules : conteneur <code>ptr-array</code>, analyseur <code>split-line</code>, et leur développement à partir de tests. qui sont testés continuellement, en particulier l’absence de fuites mémoires.</p>
<h1 data-number="8" id="annexes"><span class="header-section-number">8</span> Annexes</h1>
<h2 data-number="8.1" id="code-entier-mini-shell.c"><span class="header-section-number">8.1</span> Code entier <code>mini-shell.c</code></h2>
<p>Le code est présenté en entier, avec les directives <code>include</code> nécessaires, et dans l’ordre :</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="co">// mini-shell.c</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;sys/wait.h&gt;</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true"></a></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;ptr-array.h&quot;</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;split-line.h&quot;</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true"></a></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true"></a><span class="pp">#define SHELL_NAME &quot;Mini Shell V1.1&quot;</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true"></a></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true"></a></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true"></a><span class="co">// all commands receive an array of args</span></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true"></a><span class="co">// and return a command_result</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true"></a></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true"></a><span class="kw">struct</span> command_result {</span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true"></a>    <span class="dt">bool</span> exit_shell;</span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true"></a>    <span class="dt">int</span>  status;</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true"></a>    <span class="dt">int</span>  errnum;</span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true"></a>};</span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true"></a></span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">struct</span> command_result (*FUNCTION)(</span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true"></a>    <span class="dt">const</span> <span class="kw">struct</span> ptr_array *</span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true"></a>);</span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true"></a></span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true"></a><span class="co">// ------------------------------------------</span></span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true"></a><span class="co">// table of internal commands</span></span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true"></a><span class="co">//</span></span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true"></a></span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true"></a><span class="kw">struct</span> command_result execute_internal_exit(</span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true"></a>    <span class="dt">const</span> <span class="kw">struct</span> ptr_array *args)</span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true"></a>{</span>
<span id="cb22-39"><a href="#cb22-39" aria-hidden="true"></a>    <span class="dt">int</span> status = pa_size(args) == <span class="dv">1</span></span>
<span id="cb22-40"><a href="#cb22-40" aria-hidden="true"></a>                  ? EXIT_SUCCESS</span>
<span id="cb22-41"><a href="#cb22-41" aria-hidden="true"></a>                  : atoi(pa_get(args, <span class="dv">1</span>));</span>
<span id="cb22-42"><a href="#cb22-42" aria-hidden="true"></a>    <span class="cf">return</span> (<span class="kw">struct</span> command_result) {</span>
<span id="cb22-43"><a href="#cb22-43" aria-hidden="true"></a>        .exit_shell = true,</span>
<span id="cb22-44"><a href="#cb22-44" aria-hidden="true"></a>        .status = status,</span>
<span id="cb22-45"><a href="#cb22-45" aria-hidden="true"></a>        .errnum = <span class="dv">0</span></span>
<span id="cb22-46"><a href="#cb22-46" aria-hidden="true"></a>    };</span>
<span id="cb22-47"><a href="#cb22-47" aria-hidden="true"></a>}</span>
<span id="cb22-48"><a href="#cb22-48" aria-hidden="true"></a></span>
<span id="cb22-49"><a href="#cb22-49" aria-hidden="true"></a><span class="kw">struct</span> command_result execute_internal_cd(</span>
<span id="cb22-50"><a href="#cb22-50" aria-hidden="true"></a>    <span class="dt">const</span> <span class="kw">struct</span> ptr_array *args)</span>
<span id="cb22-51"><a href="#cb22-51" aria-hidden="true"></a>{</span>
<span id="cb22-52"><a href="#cb22-52" aria-hidden="true"></a>    <span class="dt">char</span> *dest = pa_size(args) == <span class="dv">1</span></span>
<span id="cb22-53"><a href="#cb22-53" aria-hidden="true"></a>                 ? getenv(<span class="st">&quot;HOME&quot;</span>)</span>
<span id="cb22-54"><a href="#cb22-54" aria-hidden="true"></a>                 : pa_get(args, <span class="dv">1</span>);</span>
<span id="cb22-55"><a href="#cb22-55" aria-hidden="true"></a>    <span class="dt">int</span> status = chdir(dest);</span>
<span id="cb22-56"><a href="#cb22-56" aria-hidden="true"></a>    <span class="cf">return</span> (<span class="kw">struct</span> command_result) {</span>
<span id="cb22-57"><a href="#cb22-57" aria-hidden="true"></a>        .exit_shell = false,</span>
<span id="cb22-58"><a href="#cb22-58" aria-hidden="true"></a>        .status = status,</span>
<span id="cb22-59"><a href="#cb22-59" aria-hidden="true"></a>        .errnum = errno</span>
<span id="cb22-60"><a href="#cb22-60" aria-hidden="true"></a>    };</span>
<span id="cb22-61"><a href="#cb22-61" aria-hidden="true"></a>}</span>
<span id="cb22-62"><a href="#cb22-62" aria-hidden="true"></a></span>
<span id="cb22-63"><a href="#cb22-63" aria-hidden="true"></a><span class="kw">struct</span> command_result execute_internal_help(</span>
<span id="cb22-64"><a href="#cb22-64" aria-hidden="true"></a>    <span class="dt">const</span> <span class="kw">struct</span> ptr_array *args)</span>
<span id="cb22-65"><a href="#cb22-65" aria-hidden="true"></a>{</span>
<span id="cb22-66"><a href="#cb22-66" aria-hidden="true"></a>    printf(<span class="st">&quot;Commands: </span><span class="sc">\n</span><span class="st">&quot;</span></span>
<span id="cb22-67"><a href="#cb22-67" aria-hidden="true"></a>           <span class="st">&quot;</span><span class="sc">\t</span><span class="st">exit [value] leave the shell</span><span class="sc">\n</span><span class="st">&quot;</span></span>
<span id="cb22-68"><a href="#cb22-68" aria-hidden="true"></a>           <span class="st">&quot;</span><span class="sc">\t</span><span class="st">cd  [dir]     change current directory (default: home)</span><span class="sc">\n</span><span class="st">&quot;</span></span>
<span id="cb22-69"><a href="#cb22-69" aria-hidden="true"></a>           <span class="st">&quot;</span><span class="sc">\t</span><span class="st">help  | ?     this message</span><span class="sc">\n</span><span class="st">&quot;</span></span>
<span id="cb22-70"><a href="#cb22-70" aria-hidden="true"></a>          );</span>
<span id="cb22-71"><a href="#cb22-71" aria-hidden="true"></a>    <span class="cf">return</span> (<span class="kw">struct</span> command_result) {</span>
<span id="cb22-72"><a href="#cb22-72" aria-hidden="true"></a>        .exit_shell = false,</span>
<span id="cb22-73"><a href="#cb22-73" aria-hidden="true"></a>        .status = <span class="dv">0</span>,</span>
<span id="cb22-74"><a href="#cb22-74" aria-hidden="true"></a>        .errnum = <span class="dv">0</span></span>
<span id="cb22-75"><a href="#cb22-75" aria-hidden="true"></a>    };</span>
<span id="cb22-76"><a href="#cb22-76" aria-hidden="true"></a>}</span>
<span id="cb22-77"><a href="#cb22-77" aria-hidden="true"></a></span>
<span id="cb22-78"><a href="#cb22-78" aria-hidden="true"></a><span class="co">// -----------------------------------------------------</span></span>
<span id="cb22-79"><a href="#cb22-79" aria-hidden="true"></a><span class="co">// table of internal commands :</span></span>
<span id="cb22-80"><a href="#cb22-80" aria-hidden="true"></a><span class="co">//     </span></span>
<span id="cb22-81"><a href="#cb22-81" aria-hidden="true"></a><span class="kw">struct</span> {</span>
<span id="cb22-82"><a href="#cb22-82" aria-hidden="true"></a>    <span class="dt">const</span> <span class="dt">char</span> *name;</span>
<span id="cb22-83"><a href="#cb22-83" aria-hidden="true"></a>    FUNCTION function;</span>
<span id="cb22-84"><a href="#cb22-84" aria-hidden="true"></a>} commands_table[] = {</span>
<span id="cb22-85"><a href="#cb22-85" aria-hidden="true"></a>    {<span class="st">&quot;exit&quot;</span>, &amp;execute_internal_exit},</span>
<span id="cb22-86"><a href="#cb22-86" aria-hidden="true"></a>    {<span class="st">&quot;cd&quot;</span>, &amp;execute_internal_cd},</span>
<span id="cb22-87"><a href="#cb22-87" aria-hidden="true"></a>    {<span class="st">&quot;help&quot;</span>, &amp;execute_internal_help},</span>
<span id="cb22-88"><a href="#cb22-88" aria-hidden="true"></a>    {<span class="st">&quot;?&quot;</span>, &amp;execute_internal_help},</span>
<span id="cb22-89"><a href="#cb22-89" aria-hidden="true"></a></span>
<span id="cb22-90"><a href="#cb22-90" aria-hidden="true"></a>    {NULL, NULL}</span>
<span id="cb22-91"><a href="#cb22-91" aria-hidden="true"></a>};</span>
<span id="cb22-92"><a href="#cb22-92" aria-hidden="true"></a></span>
<span id="cb22-93"><a href="#cb22-93" aria-hidden="true"></a><span class="co">// ---------------------------------------------------</span></span>
<span id="cb22-94"><a href="#cb22-94" aria-hidden="true"></a></span>
<span id="cb22-95"><a href="#cb22-95" aria-hidden="true"></a></span>
<span id="cb22-96"><a href="#cb22-96" aria-hidden="true"></a><span class="kw">struct</span> command_result execute_external_command(</span>
<span id="cb22-97"><a href="#cb22-97" aria-hidden="true"></a>    <span class="dt">const</span> <span class="kw">struct</span> ptr_array *args</span>
<span id="cb22-98"><a href="#cb22-98" aria-hidden="true"></a>)</span>
<span id="cb22-99"><a href="#cb22-99" aria-hidden="true"></a>{</span>
<span id="cb22-100"><a href="#cb22-100" aria-hidden="true"></a>    pid_t child_pid = fork();</span>
<span id="cb22-101"><a href="#cb22-101" aria-hidden="true"></a>    <span class="cf">if</span> (child_pid == <span class="dv">0</span>) {</span>
<span id="cb22-102"><a href="#cb22-102" aria-hidden="true"></a>        <span class="co">// build array</span></span>
<span id="cb22-103"><a href="#cb22-103" aria-hidden="true"></a>        <span class="dt">size_t</span> nb_args = pa_size(args);</span>
<span id="cb22-104"><a href="#cb22-104" aria-hidden="true"></a>        <span class="dt">char</span> **a = malloc(<span class="kw">sizeof</span>(<span class="dt">char</span> *)</span>
<span id="cb22-105"><a href="#cb22-105" aria-hidden="true"></a>                          * (nb_args + <span class="dv">1</span>));</span>
<span id="cb22-106"><a href="#cb22-106" aria-hidden="true"></a>        <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; nb_args; i++) {</span>
<span id="cb22-107"><a href="#cb22-107" aria-hidden="true"></a>            a[i] = pa_get(args, i);</span>
<span id="cb22-108"><a href="#cb22-108" aria-hidden="true"></a>        }</span>
<span id="cb22-109"><a href="#cb22-109" aria-hidden="true"></a>        a[nb_args] = NULL;</span>
<span id="cb22-110"><a href="#cb22-110" aria-hidden="true"></a>        execvp(a[<span class="dv">0</span>], a);</span>
<span id="cb22-111"><a href="#cb22-111" aria-hidden="true"></a>        <span class="co">// if failed</span></span>
<span id="cb22-112"><a href="#cb22-112" aria-hidden="true"></a>        perror(<span class="st">&quot;execvp failed&quot;</span>);</span>
<span id="cb22-113"><a href="#cb22-113" aria-hidden="true"></a>        exit (EXIT_FAILURE);</span>
<span id="cb22-114"><a href="#cb22-114" aria-hidden="true"></a>    }</span>
<span id="cb22-115"><a href="#cb22-115" aria-hidden="true"></a>    <span class="dt">int</span> wait_status;</span>
<span id="cb22-116"><a href="#cb22-116" aria-hidden="true"></a>    waitpid(child_pid, &amp;wait_status, <span class="dv">0</span>);</span>
<span id="cb22-117"><a href="#cb22-117" aria-hidden="true"></a>    <span class="cf">return</span> (<span class="kw">struct</span> command_result) {</span>
<span id="cb22-118"><a href="#cb22-118" aria-hidden="true"></a>        .exit_shell = false,</span>
<span id="cb22-119"><a href="#cb22-119" aria-hidden="true"></a>        .errnum = <span class="dv">0</span>,</span>
<span id="cb22-120"><a href="#cb22-120" aria-hidden="true"></a>        .status = WEXITSTATUS(wait_status)</span>
<span id="cb22-121"><a href="#cb22-121" aria-hidden="true"></a>    };</span>
<span id="cb22-122"><a href="#cb22-122" aria-hidden="true"></a>}</span>
<span id="cb22-123"><a href="#cb22-123" aria-hidden="true"></a></span>
<span id="cb22-124"><a href="#cb22-124" aria-hidden="true"></a><span class="kw">struct</span> command_result execute_command(</span>
<span id="cb22-125"><a href="#cb22-125" aria-hidden="true"></a>    <span class="kw">struct</span> ptr_array *args</span>
<span id="cb22-126"><a href="#cb22-126" aria-hidden="true"></a>)</span>
<span id="cb22-127"><a href="#cb22-127" aria-hidden="true"></a>{</span>
<span id="cb22-128"><a href="#cb22-128" aria-hidden="true"></a>    <span class="dt">const</span> <span class="dt">char</span> * name = pa_get(args, <span class="dv">0</span>);</span>
<span id="cb22-129"><a href="#cb22-129" aria-hidden="true"></a>    FUNCTION function = &amp;execute_external_command;</span>
<span id="cb22-130"><a href="#cb22-130" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; commands_table[i].name != NULL; i++) {</span>
<span id="cb22-131"><a href="#cb22-131" aria-hidden="true"></a>        <span class="cf">if</span> (strcmp(commands_table[i].name, name) == <span class="dv">0</span>) {</span>
<span id="cb22-132"><a href="#cb22-132" aria-hidden="true"></a>            <span class="co">// internal command found</span></span>
<span id="cb22-133"><a href="#cb22-133" aria-hidden="true"></a>            function = commands_table[i].function;</span>
<span id="cb22-134"><a href="#cb22-134" aria-hidden="true"></a>            <span class="cf">break</span>;</span>
<span id="cb22-135"><a href="#cb22-135" aria-hidden="true"></a>        }</span>
<span id="cb22-136"><a href="#cb22-136" aria-hidden="true"></a>    }</span>
<span id="cb22-137"><a href="#cb22-137" aria-hidden="true"></a>    <span class="co">// apply function to args</span></span>
<span id="cb22-138"><a href="#cb22-138" aria-hidden="true"></a>    <span class="cf">return</span> (*function)(args);</span>
<span id="cb22-139"><a href="#cb22-139" aria-hidden="true"></a>}</span>
<span id="cb22-140"><a href="#cb22-140" aria-hidden="true"></a></span>
<span id="cb22-141"><a href="#cb22-141" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb22-142"><a href="#cb22-142" aria-hidden="true"></a>{</span>
<span id="cb22-143"><a href="#cb22-143" aria-hidden="true"></a>    <span class="dt">char</span> *line = NULL;</span>
<span id="cb22-144"><a href="#cb22-144" aria-hidden="true"></a>    <span class="dt">size_t</span> line_size = <span class="dv">0</span>;</span>
<span id="cb22-145"><a href="#cb22-145" aria-hidden="true"></a>    <span class="dt">int</span> final_status = EXIT_SUCCESS;</span>
<span id="cb22-146"><a href="#cb22-146" aria-hidden="true"></a>    printf(<span class="st">&quot;--- Hello, this is &quot;</span> SHELL_NAME <span class="st">&quot;!</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb22-147"><a href="#cb22-147" aria-hidden="true"></a></span>
<span id="cb22-148"><a href="#cb22-148" aria-hidden="true"></a>    <span class="dt">int</span> numero = <span class="dv">1</span>;</span>
<span id="cb22-149"><a href="#cb22-149" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">bool</span> run_loop = true; run_loop; ) {</span>
<span id="cb22-150"><a href="#cb22-150" aria-hidden="true"></a>        printf(<span class="st">&quot;%d&gt; &quot;</span>, numero);</span>
<span id="cb22-151"><a href="#cb22-151" aria-hidden="true"></a>        <span class="dt">int</span> length = getline(&amp; line, &amp;line_size, stdin);</span>
<span id="cb22-152"><a href="#cb22-152" aria-hidden="true"></a>        <span class="cf">if</span> (length &lt; <span class="dv">0</span>) {</span>
<span id="cb22-153"><a href="#cb22-153" aria-hidden="true"></a>            <span class="cf">break</span>;</span>
<span id="cb22-154"><a href="#cb22-154" aria-hidden="true"></a>        }</span>
<span id="cb22-155"><a href="#cb22-155" aria-hidden="true"></a>        <span class="kw">struct</span> split_line_result slr = split_line(line);</span>
<span id="cb22-156"><a href="#cb22-156" aria-hidden="true"></a>        <span class="cf">if</span> (slr.error_message != NULL) {</span>
<span id="cb22-157"><a href="#cb22-157" aria-hidden="true"></a>            printf(<span class="st">&quot;Syntax Error at char %zu: %s</span><span class="sc">\n</span><span class="st">&quot;</span>,</span>
<span id="cb22-158"><a href="#cb22-158" aria-hidden="true"></a>                   slr.error_position, slr.error_message);</span>
<span id="cb22-159"><a href="#cb22-159" aria-hidden="true"></a>        } <span class="cf">else</span> {</span>
<span id="cb22-160"><a href="#cb22-160" aria-hidden="true"></a>            <span class="cf">if</span> (pa_size(&amp; slr.strings) != <span class="dv">0</span>) {</span>
<span id="cb22-161"><a href="#cb22-161" aria-hidden="true"></a>                <span class="kw">struct</span> command_result cr = execute_command(&amp; slr.strings);</span>
<span id="cb22-162"><a href="#cb22-162" aria-hidden="true"></a>                numero += <span class="dv">1</span>;  <span class="co">// doesn&#39;t advance if empty command</span></span>
<span id="cb22-163"><a href="#cb22-163" aria-hidden="true"></a>                <span class="cf">if</span> (cr.errnum != <span class="dv">0</span>) {</span>
<span id="cb22-164"><a href="#cb22-164" aria-hidden="true"></a>                    printf(<span class="st">&quot;Error: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, strerror(cr.errnum));</span>
<span id="cb22-165"><a href="#cb22-165" aria-hidden="true"></a>                }</span>
<span id="cb22-166"><a href="#cb22-166" aria-hidden="true"></a>                <span class="cf">if</span> (cr.exit_shell) {</span>
<span id="cb22-167"><a href="#cb22-167" aria-hidden="true"></a>                    run_loop = false;</span>
<span id="cb22-168"><a href="#cb22-168" aria-hidden="true"></a>                    final_status = cr.status;</span>
<span id="cb22-169"><a href="#cb22-169" aria-hidden="true"></a>                }</span>
<span id="cb22-170"><a href="#cb22-170" aria-hidden="true"></a>            }</span>
<span id="cb22-171"><a href="#cb22-171" aria-hidden="true"></a>        }</span>
<span id="cb22-172"><a href="#cb22-172" aria-hidden="true"></a>        split_line_result_delete(&amp; slr);</span>
<span id="cb22-173"><a href="#cb22-173" aria-hidden="true"></a>    }</span>
<span id="cb22-174"><a href="#cb22-174" aria-hidden="true"></a></span>
<span id="cb22-175"><a href="#cb22-175" aria-hidden="true"></a>    printf(<span class="st">&quot;Bye!</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb22-176"><a href="#cb22-176" aria-hidden="true"></a>    free(line);</span>
<span id="cb22-177"><a href="#cb22-177" aria-hidden="true"></a>    <span class="cf">return</span> final_status;</span>
<span id="cb22-178"><a href="#cb22-178" aria-hidden="true"></a>}</span></code></pre></div>
<h2 data-number="8.2" id="makefile-utilisé"><span class="header-section-number">8.2</span> <code>Makefile</code> utilisé</h2>
<p>Un <code>Makefile</code> est utilisé pour</p>
<ul>
<li><dl>
<dt>générer automatiquement les dépendances des sources</dt>
<dd>option <code>-MMD</code> de <code>gcc</code>, inclusion par <code>-include $(wildcard *.d)</code>),
</dd>
</dl></li>
<li>lancer systématiquement tous les tests unitaires à chaque recompilation.</li>
</ul>
<p>La composition de chaque exécutable est décrite par une ligne. Exemple</p>
<pre><code>mini-shell: split-line.o ptr-array.o</code></pre>
<p>dit que l’exécutable <code>mini-shell</code> nécessite les fichiers objets <code>split-line.o</code> et <code>ptr-array.o</code> (en plus de <code>mini-shell.o</code>).</p>
<p>Le source du <code>Makefile</code> :</p>
<pre class="make"><code>CFLAGS = -std=c17
CFLAGS += -Wall -Wextra -pedantic -Werror -Wno-unused
CFLAGS += -MMD
CFLAGS += -D_XOPEN_SOURCE=700
CFLAGS += -g

VALGRIND_OPTIONS = -s -q --leak-check=full


TESTS = tests-ptr-array 
TESTS += tests-split-line

# EXECS = demo-boucle
EXECS += mini-shell

all : tests execs

tests : $(TESTS)
    for p in $(TESTS) ; do valgrind $(VALGRIND_OPTIONS) ./$$p ; done


execs : $(EXECS)
    for p in $(EXECS) ; do ./$$p ; done


# composition des exécutables

tests-ptr-array:    ptr-array.o
tests-split-line:   split-line.o   ptr-array.o

mini-shell: split-line.o ptr-array.o

# dépendances automatiques

-include $(wildcard *.d)

# utilitaires

clean:
    $(RM) *~ *.o *.d

mrproper: clean
    $(RM) $(EXECS) $(TESTS)</code></pre>
<h2 data-number="8.3" id="exemple-de-recompilation-complète"><span class="header-section-number">8.3</span> Exemple de recompilation complète</h2>
<p>En lançant <code>make</code> après avoir nettoyé le répertoire, on obtient</p>
<ul>
<li>la compilation séparée des différents modules</li>
<li>la fabrication des exécutables</li>
<li>l’exécution des tests unitaires</li>
<li>le lancement du mini-shell</li>
</ul>
<pre><code>$ make
cc -std=c17 -Wall -Wextra -pedantic -Werror -Wno-unused -MMD -D_XOPEN_SOURCE=700 -g   -c -o ptr-array.o ptr-array.c
cc -std=c17 -Wall -Wextra -pedantic -Werror -Wno-unused -MMD -D_XOPEN_SOURCE=700 -g    tests-ptr-array.c ptr-array.o   -o tests-ptr-array
cc -std=c17 -Wall -Wextra -pedantic -Werror -Wno-unused -MMD -D_XOPEN_SOURCE=700 -g   -c -o split-line.o split-line.c
cc -std=c17 -Wall -Wextra -pedantic -Werror -Wno-unused -MMD -D_XOPEN_SOURCE=700 -g    tests-split-line.c split-line.o ptr-array.o   -o tests-split-line
for p in tests-ptr-array  tests-split-line ; do valgrind -s -q --leak-check=full ./$p ; done
# Tests ptr_array
- basic_test()
Ok
==4708== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
# tests split-line
- test_empty_lines()
- basic_test()
Ok
==4709== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
cc -std=c17 -Wall -Wextra -pedantic -Werror -Wno-unused -MMD -D_XOPEN_SOURCE=700 -g    mini-shell.c split-line.o ptr-array.o   -o mini-shell
for p in mini-shell ; do ./$p ; done
--- Hello, this is Mini Shell V1.1!
1&gt; 
</code></pre>
</body>
</html>
